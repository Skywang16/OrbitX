# 错误处理开发规范

## 概述

本文档定义了 OrbitX 项目中错误处理的开发标准和最佳实践。所有开发者在编写代码时必须遵循本规范，以确保错误处理的一致性和可维护性。

## 架构概览

OrbitX 项目采用分层错误处理架构：

```text
前端 Vue.js
    ↓ (API调用)
Tauri 命令层 (TauriApiResult<T>)
    ↓ (错误转换)
业务逻辑层 (Result<T, ModuleError>)  ← 使用 thiserror 定义的结构化错误
    ↓ (国际化处理)
用户界面 (本地化错误消息)
```

**错误处理策略**：统一使用 `thiserror` 定义结构化错误类型，每个模块定义自己的 Error 枚举。

## 基本原则

### 1. 统一错误类型 🎯

**规范：** 每个模块使用 `thiserror` 定义自己的结构化错误类型，使用 `Result<T, ModuleError>` 作为业务逻辑层的返回类型，使用 `TauriApiResult<T>` 作为 Tauri 命令层的返回类型。

```rust
✅ 正确做法：
use thiserror::Error;

// 1. 定义模块错误类型
#[derive(Error, Debug)]
pub enum ConfigError {
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),

    #[error("Parse error: {0}")]
    ParseError(#[from] toml::de::Error),

    #[error("Config not found: {0}")]
    NotFound(String),

    #[error("Invalid config: {0}")]
    Invalid(String),
}

pub type ConfigResult<T> = Result<T, ConfigError>;

// 2. 业务逻辑层
pub async fn load_config(path: &Path) -> ConfigResult<AppConfig> {
    // 自动转换 io::Error (因为有 #[from])
    let content = fs::read_to_string(path)?;

    // 自动转换 toml::de::Error (因为有 #[from])
    let config = toml::from_str(&content)?;

    Ok(config)
}

// 3. Tauri 命令层 - 转换为用户友好错误
#[tauri::command]
pub async fn get_config() -> TauriApiResult<AppConfig> {
    match load_config(Path::new("config.toml")).await {
        Ok(config) => Ok(api_success!(config)),
        Err(e) => {
            error!("Failed to load config: {:?}", e);  // 技术日志（英文）

            // 根据错误类型返回不同的用户错误
            let error_key = match e {
                ConfigError::NotFound(_) => "config.not_found",
                ConfigError::Invalid(_) => "config.invalid",
                _ => "config.get_failed",
            };

            Ok(api_error!(error_key))  // 用户错误（i18n）
        }
    }
}

❌ 错误做法：
// 不要使用 anyhow::Result
use anyhow::{Result, Context};

pub async fn load_config() -> Result<AppConfig> {
    let content = fs::read_to_string("config.toml")
        .context("读取配置文件失败")?;  // 错误：无法区分错误类型
    Ok(config)
}
```

### 2. 自然错误传播 🔄

**规范：** 使用 `?` 操作符进行错误传播，利用 `#[from]` 属性自动转换外部错误。

```rust
✅ 正确做法：
// 定义错误类型时使用 #[from]
#[derive(Error, Debug)]
pub enum DataError {
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),

    #[error("Parse error: {0}")]
    ParseError(#[from] serde_json::Error),

    #[error("Transform failed: {0}")]
    TransformFailed(String),
}

pub type DataResult<T> = Result<T, DataError>;

// 使用 ? 操作符，自动转换
pub async fn process_data(path: &Path) -> DataResult<ProcessedData> {
    let raw_data = fs::read_to_string(path)?;  // io::Error 自动转换
    let parsed = serde_json::from_str(&raw_data)?;  // serde_json::Error 自动转换
    let processed = transform_data(parsed)?;
    Ok(processed)
}

❌ 错误做法：
// 不要手动进行错误转换
pub async fn process_data(path: &Path) -> DataResult<ProcessedData> {
    let raw_data = fs::read_to_string(path)
        .map_err(|e| DataError::IoError(e))?;  // 多余！有 #[from] 就不需要
    Ok(processed)
}
```

### 3. 丰富的错误信息 📝

**规范：** 错误消息使用英文（技术错误），为业务错误提供具体的错误变体。

```rust
✅ 正确做法：
#[derive(Error, Debug)]
pub enum StorageError {
    #[error("File not found: {0}")]
    FileNotFound(PathBuf),

    #[error("Failed to write file {path}: {source}")]
    WriteFailed {
        path: PathBuf,
        source: std::io::Error,
    },

    #[error("Invalid file format: expected {expected}, got {actual}")]
    InvalidFormat {
        expected: String,
        actual: String,
    },
}

pub async fn save_file(path: &Path, content: &str) -> Result<(), StorageError> {
    fs::write(path, content)
        .map_err(|e| StorageError::WriteFailed {
            path: path.to_path_buf(),
            source: e,
        })?;
    Ok(())
}

❌ 错误做法：
// 不要使用模糊的错误信息
#[derive(Error, Debug)]
pub enum StorageError {
    #[error("操作失败")]  // 错误：中文 + 信息不具体
    OperationFailed,
}
```

## Tauri 命令规范

### 1. 统一的返回类型 🎯

**规范：** 所有 Tauri 命令必须返回 `TauriApiResult<T>` 类型，使用 `ApiResponse` 结构包装响应数据。

```rust
// 在 utils/api_response.rs 中定义
pub type TauriApiResult<T> = Result<ApiResponse<T>, String>;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ApiResponse<T> {
    pub code: u16,
    pub message: Option<String>,
    pub data: Option<T>,
}

impl<T> ApiResponse<T> {
    pub fn ok(data: T) -> Self {
        Self {
            code: 200,
            message: None,
            data: Some(data),
        }
    }

    pub fn error(message: impl Into<String>) -> Self {
        Self {
            code: 500,
            message: Some(message.into()),
            data: None,
        }
    }

    // 错误响应也可以包含数据（根据业务需要）
    pub fn error_with_data(message: impl Into<String>, data: T) -> Self {
        Self {
            code: 500,
            message: Some(message.into()),
            data: Some(data),
        }
    }
}
```

### 2. 标准命令模板 📋

**规范：** 所有 Tauri 命令必须遵循以下模板，使用国际化错误消息。

```rust
✅ 正确做法：
#[tauri::command]
pub async fn workspace_build_index(
    request: BuildWorkspaceIndexRequest,
    ai_state: State<'_, AIManagerState>,
) -> TauriApiResult<WorkspaceIndex> {
    info!("开始构建工作区索引: request={:?}", request);

    // 1. 参数验证
    if let Some(ref n) = request.name {
        if n.trim().is_empty() {
            return Ok(api_error!("storage.workspace_name_empty"));
        }
    }

    // 2. 业务逻辑处理
    let index_service = WorkspaceIndexService::new(Arc::clone(&ai_state.repositories));

    match index_service
        .workspace_build_index(&request.path, request.name)
        .await
    {
        Ok(workspace_index) => {
            info!("工作区索引构建任务已启动: {}", workspace_index.workspace_path);
            Ok(api_success!(workspace_index))
        }
        Err(e) => {
            error!("构建工作区索引失败: {}", e);
            // 3. 错误分类和国际化 - 使用错误类型而不是字符串匹配
            match e.downcast_ref::<WorkspaceIndexError>() {
                Some(WorkspaceIndexError::NetworkError(_)) => {
                    Ok(api_error!("storage.build_index_network_error"))
                }
                Some(WorkspaceIndexError::PathNotFound(_)) => {
                    Ok(api_error!("storage.workspace_path_not_exist"))
                }
                Some(WorkspaceIndexError::IndexAlreadyExists(_)) => {
                    Ok(api_error!("storage.workspace_index_already_exists"))
                }
                _ => {
                    Ok(api_error!("storage.build_index_failed"))
                }
            }
        }
    }
}

❌ 错误做法：
// 不要使用字符串匹配进行错误分类
Err(e) => {
    let error_string = e.to_string();
    if error_string.contains("网络连接失败") {  // 错误：依赖错误消息文本
        Ok(api_error!("storage.build_index_network_error"))
    } else if error_string.contains("工作区路径不存在") {  // 错误：不可靠
        Ok(api_error!("storage.workspace_path_not_exist"))
    } else {
        Ok(api_error!("storage.build_index_failed"))
    }
}

// 不要直接返回 Result<T, String>
#[tauri::command]
pub async fn build_index(path: String) -> Result<WorkspaceIndex, String> {
    if path.trim().is_empty() {
        return Err("路径不能为空".to_string());  // 错误：硬编码错误消息
    }

    match build_workspace_index(path).await {
        Ok(index) => Ok(index),
        Err(e) => Err(format!("构建索引失败: {}", e))  // 错误：不使用国际化
    }
}
```

### 3. 错误处理宏系统 💬

**规范：** 使用统一的错误处理宏，支持国际化和参数插值。

```rust
✅ 正确做法：
// 使用 api_error! 宏处理错误
Ok(api_error!("storage.workspace_name_empty"))

// 带参数的错误消息
Ok(api_error!("ai.test_connection_error", "error" => e.to_string()))

// 使用 api_success! 宏处理成功响应
Ok(api_success!(workspace_index))

// 空数据成功响应
Ok(api_success!())

❌ 错误做法：
// 不要手动构造 ApiResponse
Ok(ApiResponse {
    code: 500,
    message: Some("操作失败".to_string()),
    data: None,
})
```

## 国际化错误处理规范

### 1. 错误消息国际化 🌍

**规范：** 所有面向用户的错误消息必须支持国际化，使用 i18n key 而不是硬编码文本。

```rust
✅ 正确做法：
// 在 utils/i18n/zh-CN.json 和 en-US.json 中定义错误消息
{
  "storage": {
    "workspace_name_empty": "工作区名称不能为空",
    "build_index_network_error": "无法下载所需的模型文件，请检查网络连接或稍后重试",
    "workspace_path_not_exist": "工作区路径不存在"
  }
}

// 在 Rust 代码中使用 i18n key
Ok(api_error!("storage.workspace_name_empty"))
Ok(api_error!("storage.build_index_network_error"))

❌ 错误做法：
// 不要硬编码错误消息
Ok(api_error!("工作区名称不能为空"))
Ok(ApiResponse::error("Workspace name cannot be empty"))
```

### 2. 带参数的错误消息 📝

**规范：** 支持参数插值的错误消息，提供更详细的错误信息。

```rust
✅ 正确做法：
// 在 i18n 文件中定义带参数的消息
{
  "ai": {
    "test_connection_error": "连接测试失败: {error}"
  }
}

// 在代码中使用参数
Ok(api_error!("ai.test_connection_error", "error" => e.to_string()))

// 使用 t! 宏进行文本国际化
let message = t!("ai.test_connection_error", "error" => "网络超时");
```

### 3. 错误消息分类 🏷️

**规范：** 按模块和功能对错误消息进行分类，便于管理和维护。

```rust
✅ 正确的分类结构：
{
  "common": {
    "operation_failed": "操作失败",
    "invalid_params": "参数无效",
    "not_found": "资源不存在"
  },
  "storage": {
    "workspace_name_empty": "工作区名称不能为空",
    "build_index_failed": "索引构建失败"
  },
  "ai": {
    "model_not_found": "模型不存在",
    "api_key_empty": "API Key不能为空"
  }
}
```

## 模块级错误处理规范

### 1. 统一的导入声明 📦

**规范：** 每个模块的错误处理导入必须标准化。

```rust
✅ 正确做法：
// 在错误定义模块 (error.rs)
use thiserror::Error;

// 在 Tauri 命令模块顶部
use crate::module::error::{ModuleError, ModuleResult};
use crate::utils::{ApiResponse, EmptyData, TauriApiResult};
use crate::{api_error, api_success, t};
use tracing::{debug, error, info, warn};

// 在业务逻辑模块顶部
use crate::module::error::{ModuleError, ModuleResult};
use tracing::{debug, error, info, warn};
```

### 2. 错误处理函数命名 🏷️

**规范：** 错误处理相关的函数必须使用清晰的命名。

```rust
✅ 正确做法：
pub async fn validate_config(config: &AppConfig) -> Result<()>
pub async fn ensure_directory_exists(path: &Path) -> Result<()>
pub async fn handle_network_timeout() -> Result<()>

❌ 错误做法：
pub async fn check(config: &AppConfig) -> Result<()>  // 命名不清晰
pub async fn do_work() -> Result<()>                 // 命名不明确
```

### 3. 参数验证规范 ✅

**规范：** 在 Tauri 命令中使用简单的条件检查，在业务逻辑中直接返回错误变体。

```rust
✅ 正确做法（Tauri 命令层）：
#[tauri::command]
pub async fn delete_workspace_index(id: i32) -> TauriApiResult<EmptyData> {
    // 简单参数验证
    if id <= 0 {
        return Ok(api_error!("storage.invalid_workspace_id"));
    }

    // 调用业务逻辑
    match workspace_service.delete_index(id).await {
        Ok(_) => Ok(api_success!()),
        Err(e) => {
            error!("Failed to delete workspace index: {:?}", e);
            
            // 根据错误类型返回不同消息
            let error_key = match e {
                StorageError::NotFound(_) => "storage.not_found",
                _ => "storage.delete_failed",
            };
            
            Ok(api_error!(error_key))
        }
    }
}

✅ 正确做法（业务逻辑层）：
#[derive(Error, Debug)]
pub enum WorkspaceError {
    #[error("Workspace name cannot be empty")]
    NameEmpty,
    
    #[error("Workspace path does not exist: {0}")]
    PathNotExist(PathBuf),
    
    #[error("Invalid workspace data")]
    InvalidData,
}

pub fn validate_workspace_config(config: &WorkspaceConfig) -> Result<(), WorkspaceError> {
    if config.name.trim().is_empty() {
        return Err(WorkspaceError::NameEmpty);
    }
    
    if !config.path.exists() {
        return Err(WorkspaceError::PathNotExist(config.path.clone()));
    }
    
    Ok(())
}

pub fn process_workspace_data(data: &str) -> Result<ProcessedData, WorkspaceError> {
    if data.is_empty() {
        return Err(WorkspaceError::InvalidData);
    }
    // 处理逻辑...
    Ok(processed_data)
}

❌ 错误做法：
// 不要使用 anyhow 的 bail! 或 ensure!
pub fn validate_config(config: &Config) -> anyhow::Result<()> {
    ensure!(!config.name.is_empty(), "名称不能为空");  // 错误：使用 anyhow
    Ok(())
}
```

## 错误级别和日志规范

### 1. 错误日志级别 📊

**规范：** 根据错误的严重程度选择合适的日志级别。

```rust
✅ 正确做法：
// 系统级错误 - error!
if let Err(e) = critical_system_operation() {
    tracing::error!("系统操作失败: {:?}", e);
    return Err(e);
}

// 业务级错误 - warn!
if let Err(e) = validate_user_input(&input) {
    tracing::warn!("用户输入验证失败: {}", e);
    return Err(e);
}

// 可恢复错误 - info!
if let Err(e) = optional_operation() {
    tracing::info!("可选操作失败，继续执行: {}", e);
    // 继续执行其他逻辑
}
```

### 2. 结构化错误日志 🏗️

**规范：** 使用结构化日志记录错误信息。

```rust
✅ 正确做法：
tracing::error!(
    error = %error,
    module = "config",
    operation = "load_config",
    path = %config_path,
    "配置加载失败"
);
```

## 测试中的错误处理规范

### 1. 测试错误场景 🧪

**规范：** 每个可能失败的函数都必须有对应的错误测试。

```rust
✅ 正确做法：
#[tokio::test]
async fn test_load_config_file_not_found() {
    let result = load_config("non_existent.toml").await;
    assert!(result.is_err());

    let error = result.unwrap_err();
    assert!(error.to_string().contains("读取配置文件失败"));
}

#[tokio::test]
async fn test_load_config_invalid_format() {
    // 创建无效的配置文件
    let invalid_content = "invalid toml content";
    fs::write("test_invalid.toml", invalid_content).await.unwrap();

    let result = load_config("test_invalid.toml").await;
    assert!(result.is_err());

    let error = result.unwrap_err();
    assert!(error.to_string().contains("解析配置文件失败"));
}
```

## 文档规范

### 1. 函数文档 📚

**规范：** 所有可能失败的函数必须在文档中说明错误条件。

````rust
✅ 正确做法：
/// 加载应用程序配置
///
/// # 错误
///
/// 在以下情况下会返回错误：
/// - 配置文件不存在
/// - 配置文件格式无效
/// - 配置文件权限不足
///
/// # 示例
///
/// ```rust
/// let config = load_config().await?;
/// ```
pub async fn load_config() -> Result<AppConfig> {
    // 实现
}
````

### 2. 错误信息规范 💬

**规范：** 错误信息必须清晰、可操作，并提供足够的上下文。

| 错误类型 | 信息格式                          | 示例                                                  |
| -------- | --------------------------------- | ----------------------------------------------------- |
| 文件操作 | "操作失败: 文件路径 (原因)"       | "读取配置文件失败: /path/to/config.toml (文件不存在)" |
| 网络请求 | "网络操作失败: URL (状态码/原因)" | "API请求失败: <https://api.example.com> (超时)"       |
| 数据验证 | "验证失败: 字段名 (具体原因)"     | "参数验证失败: email (格式无效)"                      |

## 前端错误处理规范

### 1. Vue 组件错误处理 🖥️

**规范：** 前端组件应优雅处理 API 错误，提供用户友好的错误提示。

```typescript
✅ 正确做法：
// 在 Vue 组件中处理 API 错误
const handleBuildWorkspaceIndex = async () => {
  const canBuild = !hasWorkspaceIndex.value &&
    currentWorkspaceIndex.value?.status !== IndexStatus.Building

  if (!canBuild) {
    console.warn('工作区索引已存在或正在构建，跳过操作')
    return
  }

  try {
    // 如果已有error状态的索引，先删除
    if (currentWorkspaceIndex.value?.status === IndexStatus.Error &&
        currentWorkspaceIndex.value?.id) {
      await workspaceIndexApi.deleteWorkspace(currentWorkspaceIndex.value.id)
    }

    const workspace = await workspaceIndexApi.buildWorkspaceIndex({
      path: currentPath,
      name: directoryName,
    })

    currentWorkspaceIndex.value = workspace
    startBuildStatusPolling() // 开始轮询构建状态
  } catch (error) {
    console.error('构建工作区索引失败:', error)
    // 错误处理由 store 或 API 层处理，组件层主要负责UI状态更新
  }
}

❌ 错误做法：
// 不要忽略错误或只是简单打印
const handleBuildIndex = async () => {
  const result = await buildIndex()
  // 没有错误处理，没有状态管理
}
```

### 2. API 响应处理 📡

**规范：** 前端应正确解析 `ApiResponse` 结构，根据 `code` 字段判断操作结果。

```typescript
✅ 正确做法：
interface ApiResponse<T> {
  code: number
  message?: string
  data?: T
}
```

### 2. API 调用规范 🔌

**规范：** 前端通过 API 服务层调用接口，不在组件中直接使用 `invoke` 函数。

```typescript
✅ 正确做法：
// API 服务层 - /src/api/workspace-index/index.ts
import { invoke } from '@/utils/request'

export class CkApi {
  async buildWorkspaceIndex(params: BuildWorkspaceIndexParams): Promise<WorkspaceIndex> {
    return await invoke<WorkspaceIndex>('workspace_build_index', {
      request: {
        path: params.path,
        name: params.name,
      },
    })
  }

  async checkCurrentWorkspace(): Promise<WorkspaceIndex | null> {
    return await invoke<WorkspaceIndex | null>('workspace_check_current_index')
  }
}

export const workspaceIndexApi = new CkApi()

// 组件中使用 - 通过 API 服务层
import { workspaceIndexApi } from '@/api/workspace-index'

const buildWorkspaceIndex = async () => {
  try {
    const workspaceIndex = await workspaceIndexApi.buildWorkspaceIndex({
      path: workspacePath.value,
      name: workspaceName.value
    })

    currentWorkspaceIndex.value = workspaceIndex
  } catch (error) {
    // 错误已在 invoke 层统一处理和显示
    console.error('构建工作区索引失败:', error)
  }
}

❌ 错误做法：
// 不要在组件中直接使用 invoke
import { invoke } from '@/utils/request'

const buildIndex = async () => {
  try {
    // 错误：组件不应该直接调用 invoke
    const workspaceIndex = await invoke<WorkspaceIndex>('workspace_build_index', { request })
    return workspaceIndex
  } catch (error) {
    console.error(error)
    throw error
  }
}
```

### 3. 错误消息显示 🌍

**规范：** 统一的 `invoke` 函数已自动处理错误提示，组件通过 API 服务层调用，无需额外的错误消息处理。

````vue
<script setup lang="ts">
  import { workspaceIndexApi } from '@/api/workspace-index'

  // API 调用示例 - 通过 API 服务层
  const buildWorkspaceIndex = async () => {
    try {
      // API 服务层内部使用 invoke 函数，已处理：
      // 1. 解析 ApiResponse<T> 结构
      // 2. 失败时调用 createMessage.error() 显示错误
      // 3. 成功时直接返回 data
      const workspaceIndex = await workspaceIndexApi.buildWorkspaceIndex({
        path: workspacePath.value,
        name: workspaceName.value,
      })

      // 直接使用返回的数据
      currentWorkspaceIndex.value = workspaceIndex
    } catch (error) {
      // 错误提示已在 invoke 层自动显示
      // 这里只需要处理 UI 状态或业务逻辑
      console.error('构建工作区索引失败:', error)
    }
  }
</script>

<template>
  <!-- 工作区索引状态显示 -->
  <div v-if="hasWorkspaceIndex" class="index-status">
    {{ t('storage.index_ready') }}
  </div>

  <div v-else-if="currentWorkspaceIndex?.status === IndexStatus.Building" class="building-status">
    {{ t('storage.building_workspace_index') }}
  </div>

  <div v-else-if="isIndexInError" class="error-status">
    {{ t('storage.index_error') }}
  </div>

  <!-- 无需手动显示错误 - 统一层已处理 -->
</template>

❌ 错误做法： ```vue
<script setup lang="ts">
  // 不要在组件中直接使用 invoke
  import { invoke } from '@/utils/request'

  const buildWorkspaceIndex = async () => {
    try {
      // 错误：组件不应该直接调用 invoke
      const workspaceIndex = await invoke<WorkspaceIndex>('workspace_build_index', { request })
      currentWorkspaceIndex.value = workspaceIndex
    } catch (error) {
      console.error(error)
    }
  }

  // 不要手动处理 ApiResponse 结构
  const buildIndex = async () => {
    try {
      const response = await api.invoke<ApiResponse<WorkspaceIndex>>('workspace_build_index', { request })

      if (response.code === 200 && response.data) {
        // 错误：手动处理响应结构，应该让 API 服务层处理
        currentWorkspaceIndex.value = response.data
      } else {
        throw new Error(response.message || '操作失败')
      }
    } catch (error) {
      handleApiError(error as Error)
    }
  }
</script>
````

### 4. 错误状态管理 📊

**规范：** 使用响应式状态管理错误信息，提供一致的用户体验。

```typescript
✅ 正确做法：
// 在组件中管理错误状态
const currentWorkspaceIndex = ref<WorkspaceIndex | null>(null)
const isLoading = ref(false)
const errorState = ref<{
  hasError: boolean
  message: string
  type: 'network' | 'validation' | 'system' | null
}>({
  hasError: false,
  message: '',
  type: null
})

// 计算属性用于UI状态判断
const hasWorkspaceIndex = computed(() => {
  return currentWorkspaceIndex.value?.status === IndexStatus.Ready
})

const isIndexInError = computed(() => {
  return currentWorkspaceIndex.value?.status === IndexStatus.Error
})

const canBuildIndex = computed(() => {
  return !hasWorkspaceIndex.value &&
         currentWorkspaceIndex.value?.status !== IndexStatus.Building &&
         !isLoading.value
})
```

## 代码审查清单

在提交代码前，请确认以下事项：

### 后端 Rust 代码

- [ ] 每个模块使用 `thiserror` 定义自己的 Error 枚举
- [ ] 定义了 `type ModuleResult<T> = Result<T, ModuleError>` 别名
- [ ] 外部错误使用 `#[from]` 属性自动转换
- [ ] 技术错误消息使用英文（在 `#[error]` 中）
- [ ] Tauri 命令返回 `TauriApiResult<T>` 类型
- [ ] 使用 `api_error!` 和 `api_success!` 宏
- [ ] 用户错误消息使用 i18n key 而不是硬编码文本
- [ ] 错误消息已在 `zh-CN.json` 和 `en-US.json` 中定义
- [ ] 使用适当的日志级别记录错误（error!, warn!, info!）
- [ ] 参数验证在 Tauri 命令层使用简单条件检查
- [ ] 业务逻辑层直接返回错误变体
- [ ] 错误分类使用模式匹配而不是字符串匹配
- [ ] 不再使用 `.into()` 进行错误转换（除非必要）
- [ ] 添加了必要的错误测试用例

### 前端 Vue.js 代码

- [ ] 通过 API 服务层调用接口，不在组件中直接使用 `invoke`
- [ ] API 服务层正确使用 `invoke` 函数处理 `ApiResponse<T>` 结构
- [ ] 组件中只处理业务逻辑和 UI 状态，不处理错误消息显示
- [ ] 错误提示已在 `invoke` 层统一处理，无需重复处理
- [ ] 错误状态通过响应式数据管理
- [ ] 计算属性用于 UI 状态判断
- [ ] 异步操作有适当的加载状态管理

## 常见反模式

### ❌ 避免这些做法

1. **使用 anyhow::Result 而不是结构化错误**

   ```rust
   // ❌ 不要这样做
   use anyhow::Result;
   
   pub async fn load_data() -> Result<Data> {
       // 错误：无法区分错误类型
   }
   
   // ✅ 应该这样做
   use thiserror::Error;
   
   #[derive(Error, Debug)]
   pub enum DataError {
       #[error("Not found: {0}")]
       NotFound(String),
   }
   
   pub async fn load_data() -> Result<Data, DataError> {
       // 正确：可以模式匹配错误类型
   }
   ```

2. **手动错误转换（当有 `#[from]` 时）**

   ```rust
   // ❌ 不要这样做
   .map_err(|e| MyError::IoError(e))?  // 多余！
   
   // ✅ 应该这样做（定义时用 #[from]）
   #[derive(Error, Debug)]
   pub enum MyError {
       #[error("IO error: {0}")]
       IoError(#[from] std::io::Error),
   }
   
   // 然后直接用 ?
   let content = fs::read_to_string(path)?;
   ```

3. **错误信息使用中文**

   ```rust
   // ❌ 不要这样做
   #[error("文件不存在")]  // 技术错误应该用英文
   
   // ✅ 应该这样做
   #[error("File not found: {0}")]  // 英文，供开发者看
   ```

4. **直接使用 unwrap()**

   ```rust
   // ❌ 不要这样做
   let result = operation().unwrap(); // 可能引起 panic
   
   // ✅ 应该这样做
   let result = operation()?; // 返回错误给调用者
   ```

5. **返回 String 类型的错误**

   ```rust
   // ❌ 不要这样做
   Err("操作失败".to_string())
   
   // ✅ 应该这样做
   Err(MyError::OperationFailed)
   ```

6. **不使用 `#[from]` 自动转换**

   ```rust
   // ❌ 不要这样做
   #[derive(Error, Debug)]
   pub enum MyError {
       #[error("IO error: {0}")]
       IoError(std::io::Error),  // 缺少 #[from]
   }
   
   // ✅ 应该这样做
   #[derive(Error, Debug)]
   pub enum MyError {
       #[error("IO error: {0}")]
       IoError(#[from] std::io::Error),  // 有 #[from]
   }
   ```

## 代码审查清单补充

### 错误类型设计

- [ ] 每个模块定义了自己的 Error 枚举（使用 thiserror）
- [ ] 错误枚举有 `type ModuleResult<T> = Result<T, ModuleError>` 别名
- [ ] 外部错误使用 `#[from]` 自动转换
- [ ] 错误消息使用英文
- [ ] 错误变体足够具体，可以区分不同情况

通过遵循这些规范，我们可以确保 OrbitX 项目中的错误处理保持一致性、可维护性和用户友好性。
