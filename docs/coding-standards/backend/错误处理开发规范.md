# é”™è¯¯å¤„ç†å¼€å‘è§„èŒƒ

## æ¦‚è¿°

æœ¬æ–‡æ¡£å®šä¹‰äº† OrbitX é¡¹ç›®ä¸­é”™è¯¯å¤„ç†çš„å¼€å‘æ ‡å‡†å’Œæœ€ä½³å®è·µã€‚æ‰€æœ‰å¼€å‘è€…åœ¨ç¼–å†™ä»£ç æ—¶å¿…é¡»éµå¾ªæœ¬è§„èŒƒï¼Œä»¥ç¡®ä¿é”™è¯¯å¤„ç†çš„ä¸€è‡´æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

## æ¶æ„æ¦‚è§ˆ

OrbitX é¡¹ç›®é‡‡ç”¨åˆ†å±‚é”™è¯¯å¤„ç†æ¶æ„ï¼š

```text
å‰ç«¯ Vue.js
    â†“ (APIè°ƒç”¨)
Tauri å‘½ä»¤å±‚ (TauriApiResult<T>)
    â†“ (é”™è¯¯è½¬æ¢)
ä¸šåŠ¡é€»è¾‘å±‚ (Result<T, ModuleError>)  â† ä½¿ç”¨ thiserror å®šä¹‰çš„ç»“æ„åŒ–é”™è¯¯
    â†“ (å›½é™…åŒ–å¤„ç†)
ç”¨æˆ·ç•Œé¢ (æœ¬åœ°åŒ–é”™è¯¯æ¶ˆæ¯)
```

**é”™è¯¯å¤„ç†ç­–ç•¥**ï¼šç»Ÿä¸€ä½¿ç”¨ `thiserror` å®šä¹‰ç»“æ„åŒ–é”™è¯¯ç±»å‹ï¼Œæ¯ä¸ªæ¨¡å—å®šä¹‰è‡ªå·±çš„ Error æšä¸¾ã€‚

## åŸºæœ¬åŸåˆ™

### 1. ç»Ÿä¸€é”™è¯¯ç±»å‹ ğŸ¯

**è§„èŒƒï¼š** æ¯ä¸ªæ¨¡å—ä½¿ç”¨ `thiserror` å®šä¹‰è‡ªå·±çš„ç»“æ„åŒ–é”™è¯¯ç±»å‹ï¼Œä½¿ç”¨ `Result<T, ModuleError>` ä½œä¸ºä¸šåŠ¡é€»è¾‘å±‚çš„è¿”å›ç±»å‹ï¼Œä½¿ç”¨ `TauriApiResult<T>` ä½œä¸º Tauri å‘½ä»¤å±‚çš„è¿”å›ç±»å‹ã€‚

```rust
âœ… æ­£ç¡®åšæ³•ï¼š
use thiserror::Error;

// 1. å®šä¹‰æ¨¡å—é”™è¯¯ç±»å‹
#[derive(Error, Debug)]
pub enum ConfigError {
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),

    #[error("Parse error: {0}")]
    ParseError(#[from] toml::de::Error),

    #[error("Config not found: {0}")]
    NotFound(String),

    #[error("Invalid config: {0}")]
    Invalid(String),
}

pub type ConfigResult<T> = Result<T, ConfigError>;

// 2. ä¸šåŠ¡é€»è¾‘å±‚
pub async fn load_config(path: &Path) -> ConfigResult<AppConfig> {
    // è‡ªåŠ¨è½¬æ¢ io::Error (å› ä¸ºæœ‰ #[from])
    let content = fs::read_to_string(path)?;

    // è‡ªåŠ¨è½¬æ¢ toml::de::Error (å› ä¸ºæœ‰ #[from])
    let config = toml::from_str(&content)?;

    Ok(config)
}

// 3. Tauri å‘½ä»¤å±‚ - è½¬æ¢ä¸ºç”¨æˆ·å‹å¥½é”™è¯¯
#[tauri::command]
pub async fn get_config() -> TauriApiResult<AppConfig> {
    match load_config(Path::new("config.toml")).await {
        Ok(config) => Ok(api_success!(config)),
        Err(e) => {
            error!("Failed to load config: {:?}", e);  // æŠ€æœ¯æ—¥å¿—ï¼ˆè‹±æ–‡ï¼‰

            // æ ¹æ®é”™è¯¯ç±»å‹è¿”å›ä¸åŒçš„ç”¨æˆ·é”™è¯¯
            let error_key = match e {
                ConfigError::NotFound(_) => "config.not_found",
                ConfigError::Invalid(_) => "config.invalid",
                _ => "config.get_failed",
            };

            Ok(api_error!(error_key))  // ç”¨æˆ·é”™è¯¯ï¼ˆi18nï¼‰
        }
    }
}

âŒ é”™è¯¯åšæ³•ï¼š
// ä¸è¦ä½¿ç”¨ anyhow::Result
use anyhow::{Result, Context};

pub async fn load_config() -> Result<AppConfig> {
    let content = fs::read_to_string("config.toml")
        .context("è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥")?;  // é”™è¯¯ï¼šæ— æ³•åŒºåˆ†é”™è¯¯ç±»å‹
    Ok(config)
}
```

### 2. è‡ªç„¶é”™è¯¯ä¼ æ’­ ğŸ”„

**è§„èŒƒï¼š** ä½¿ç”¨ `?` æ“ä½œç¬¦è¿›è¡Œé”™è¯¯ä¼ æ’­ï¼Œåˆ©ç”¨ `#[from]` å±æ€§è‡ªåŠ¨è½¬æ¢å¤–éƒ¨é”™è¯¯ã€‚

```rust
âœ… æ­£ç¡®åšæ³•ï¼š
// å®šä¹‰é”™è¯¯ç±»å‹æ—¶ä½¿ç”¨ #[from]
#[derive(Error, Debug)]
pub enum DataError {
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),

    #[error("Parse error: {0}")]
    ParseError(#[from] serde_json::Error),

    #[error("Transform failed: {0}")]
    TransformFailed(String),
}

pub type DataResult<T> = Result<T, DataError>;

// ä½¿ç”¨ ? æ“ä½œç¬¦ï¼Œè‡ªåŠ¨è½¬æ¢
pub async fn process_data(path: &Path) -> DataResult<ProcessedData> {
    let raw_data = fs::read_to_string(path)?;  // io::Error è‡ªåŠ¨è½¬æ¢
    let parsed = serde_json::from_str(&raw_data)?;  // serde_json::Error è‡ªåŠ¨è½¬æ¢
    let processed = transform_data(parsed)?;
    Ok(processed)
}

âŒ é”™è¯¯åšæ³•ï¼š
// ä¸è¦æ‰‹åŠ¨è¿›è¡Œé”™è¯¯è½¬æ¢
pub async fn process_data(path: &Path) -> DataResult<ProcessedData> {
    let raw_data = fs::read_to_string(path)
        .map_err(|e| DataError::IoError(e))?;  // å¤šä½™ï¼æœ‰ #[from] å°±ä¸éœ€è¦
    Ok(processed)
}
```

### 3. ä¸°å¯Œçš„é”™è¯¯ä¿¡æ¯ ğŸ“

**è§„èŒƒï¼š** é”™è¯¯æ¶ˆæ¯ä½¿ç”¨è‹±æ–‡ï¼ˆæŠ€æœ¯é”™è¯¯ï¼‰ï¼Œä¸ºä¸šåŠ¡é”™è¯¯æä¾›å…·ä½“çš„é”™è¯¯å˜ä½“ã€‚

```rust
âœ… æ­£ç¡®åšæ³•ï¼š
#[derive(Error, Debug)]
pub enum StorageError {
    #[error("File not found: {0}")]
    FileNotFound(PathBuf),

    #[error("Failed to write file {path}: {source}")]
    WriteFailed {
        path: PathBuf,
        source: std::io::Error,
    },

    #[error("Invalid file format: expected {expected}, got {actual}")]
    InvalidFormat {
        expected: String,
        actual: String,
    },
}

pub async fn save_file(path: &Path, content: &str) -> Result<(), StorageError> {
    fs::write(path, content)
        .map_err(|e| StorageError::WriteFailed {
            path: path.to_path_buf(),
            source: e,
        })?;
    Ok(())
}

âŒ é”™è¯¯åšæ³•ï¼š
// ä¸è¦ä½¿ç”¨æ¨¡ç³Šçš„é”™è¯¯ä¿¡æ¯
#[derive(Error, Debug)]
pub enum StorageError {
    #[error("æ“ä½œå¤±è´¥")]  // é”™è¯¯ï¼šä¸­æ–‡ + ä¿¡æ¯ä¸å…·ä½“
    OperationFailed,
}
```

## Tauri å‘½ä»¤è§„èŒƒ

### 1. ç»Ÿä¸€çš„è¿”å›ç±»å‹ ğŸ¯

**è§„èŒƒï¼š** æ‰€æœ‰ Tauri å‘½ä»¤å¿…é¡»è¿”å› `TauriApiResult<T>` ç±»å‹ï¼Œä½¿ç”¨ `ApiResponse` ç»“æ„åŒ…è£…å“åº”æ•°æ®ã€‚

```rust
// åœ¨ utils/api_response.rs ä¸­å®šä¹‰
pub type TauriApiResult<T> = Result<ApiResponse<T>, String>;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ApiResponse<T> {
    pub code: u16,
    pub message: Option<String>,
    pub data: Option<T>,
}

impl<T> ApiResponse<T> {
    pub fn ok(data: T) -> Self {
        Self {
            code: 200,
            message: None,
            data: Some(data),
        }
    }

    pub fn error(message: impl Into<String>) -> Self {
        Self {
            code: 500,
            message: Some(message.into()),
            data: None,
        }
    }

    // é”™è¯¯å“åº”ä¹Ÿå¯ä»¥åŒ…å«æ•°æ®ï¼ˆæ ¹æ®ä¸šåŠ¡éœ€è¦ï¼‰
    pub fn error_with_data(message: impl Into<String>, data: T) -> Self {
        Self {
            code: 500,
            message: Some(message.into()),
            data: Some(data),
        }
    }
}
```

### 2. æ ‡å‡†å‘½ä»¤æ¨¡æ¿ ğŸ“‹

**è§„èŒƒï¼š** æ‰€æœ‰ Tauri å‘½ä»¤å¿…é¡»éµå¾ªä»¥ä¸‹æ¨¡æ¿ï¼Œä½¿ç”¨å›½é™…åŒ–é”™è¯¯æ¶ˆæ¯ã€‚

```rust
âœ… æ­£ç¡®åšæ³•ï¼š
#[tauri::command]
pub async fn workspace_build_index(
    request: BuildWorkspaceIndexRequest,
    ai_state: State<'_, AIManagerState>,
) -> TauriApiResult<WorkspaceIndex> {
    info!("å¼€å§‹æ„å»ºå·¥ä½œåŒºç´¢å¼•: request={:?}", request);

    // 1. å‚æ•°éªŒè¯
    if let Some(ref n) = request.name {
        if n.trim().is_empty() {
            return Ok(api_error!("storage.workspace_name_empty"));
        }
    }

    // 2. ä¸šåŠ¡é€»è¾‘å¤„ç†
    let index_service = WorkspaceIndexService::new(Arc::clone(&ai_state.repositories));

    match index_service
        .workspace_build_index(&request.path, request.name)
        .await
    {
        Ok(workspace_index) => {
            info!("å·¥ä½œåŒºç´¢å¼•æ„å»ºä»»åŠ¡å·²å¯åŠ¨: {}", workspace_index.workspace_path);
            Ok(api_success!(workspace_index))
        }
        Err(e) => {
            error!("æ„å»ºå·¥ä½œåŒºç´¢å¼•å¤±è´¥: {}", e);
            // 3. é”™è¯¯åˆ†ç±»å’Œå›½é™…åŒ– - ä½¿ç”¨é”™è¯¯ç±»å‹è€Œä¸æ˜¯å­—ç¬¦ä¸²åŒ¹é…
            match e.downcast_ref::<WorkspaceIndexError>() {
                Some(WorkspaceIndexError::NetworkError(_)) => {
                    Ok(api_error!("storage.build_index_network_error"))
                }
                Some(WorkspaceIndexError::PathNotFound(_)) => {
                    Ok(api_error!("storage.workspace_path_not_exist"))
                }
                Some(WorkspaceIndexError::IndexAlreadyExists(_)) => {
                    Ok(api_error!("storage.workspace_index_already_exists"))
                }
                _ => {
                    Ok(api_error!("storage.build_index_failed"))
                }
            }
        }
    }
}

âŒ é”™è¯¯åšæ³•ï¼š
// ä¸è¦ä½¿ç”¨å­—ç¬¦ä¸²åŒ¹é…è¿›è¡Œé”™è¯¯åˆ†ç±»
Err(e) => {
    let error_string = e.to_string();
    if error_string.contains("ç½‘ç»œè¿æ¥å¤±è´¥") {  // é”™è¯¯ï¼šä¾èµ–é”™è¯¯æ¶ˆæ¯æ–‡æœ¬
        Ok(api_error!("storage.build_index_network_error"))
    } else if error_string.contains("å·¥ä½œåŒºè·¯å¾„ä¸å­˜åœ¨") {  // é”™è¯¯ï¼šä¸å¯é 
        Ok(api_error!("storage.workspace_path_not_exist"))
    } else {
        Ok(api_error!("storage.build_index_failed"))
    }
}

// ä¸è¦ç›´æ¥è¿”å› Result<T, String>
#[tauri::command]
pub async fn build_index(path: String) -> Result<WorkspaceIndex, String> {
    if path.trim().is_empty() {
        return Err("è·¯å¾„ä¸èƒ½ä¸ºç©º".to_string());  // é”™è¯¯ï¼šç¡¬ç¼–ç é”™è¯¯æ¶ˆæ¯
    }

    match build_workspace_index(path).await {
        Ok(index) => Ok(index),
        Err(e) => Err(format!("æ„å»ºç´¢å¼•å¤±è´¥: {}", e))  // é”™è¯¯ï¼šä¸ä½¿ç”¨å›½é™…åŒ–
    }
}
```

### 3. é”™è¯¯å¤„ç†å®ç³»ç»Ÿ ğŸ’¬

**è§„èŒƒï¼š** ä½¿ç”¨ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å®ï¼Œæ”¯æŒå›½é™…åŒ–å’Œå‚æ•°æ’å€¼ã€‚

```rust
âœ… æ­£ç¡®åšæ³•ï¼š
// ä½¿ç”¨ api_error! å®å¤„ç†é”™è¯¯
Ok(api_error!("storage.workspace_name_empty"))

// å¸¦å‚æ•°çš„é”™è¯¯æ¶ˆæ¯
Ok(api_error!("ai.test_connection_error", "error" => e.to_string()))

// ä½¿ç”¨ api_success! å®å¤„ç†æˆåŠŸå“åº”
Ok(api_success!(workspace_index))

// ç©ºæ•°æ®æˆåŠŸå“åº”
Ok(api_success!())

âŒ é”™è¯¯åšæ³•ï¼š
// ä¸è¦æ‰‹åŠ¨æ„é€  ApiResponse
Ok(ApiResponse {
    code: 500,
    message: Some("æ“ä½œå¤±è´¥".to_string()),
    data: None,
})
```

## å›½é™…åŒ–é”™è¯¯å¤„ç†è§„èŒƒ

### 1. é”™è¯¯æ¶ˆæ¯å›½é™…åŒ– ğŸŒ

**è§„èŒƒï¼š** æ‰€æœ‰é¢å‘ç”¨æˆ·çš„é”™è¯¯æ¶ˆæ¯å¿…é¡»æ”¯æŒå›½é™…åŒ–ï¼Œä½¿ç”¨ i18n key è€Œä¸æ˜¯ç¡¬ç¼–ç æ–‡æœ¬ã€‚

```rust
âœ… æ­£ç¡®åšæ³•ï¼š
// åœ¨ utils/i18n/zh-CN.json å’Œ en-US.json ä¸­å®šä¹‰é”™è¯¯æ¶ˆæ¯
{
  "storage": {
    "workspace_name_empty": "å·¥ä½œåŒºåç§°ä¸èƒ½ä¸ºç©º",
    "build_index_network_error": "æ— æ³•ä¸‹è½½æ‰€éœ€çš„æ¨¡å‹æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•",
    "workspace_path_not_exist": "å·¥ä½œåŒºè·¯å¾„ä¸å­˜åœ¨"
  }
}

// åœ¨ Rust ä»£ç ä¸­ä½¿ç”¨ i18n key
Ok(api_error!("storage.workspace_name_empty"))
Ok(api_error!("storage.build_index_network_error"))

âŒ é”™è¯¯åšæ³•ï¼š
// ä¸è¦ç¡¬ç¼–ç é”™è¯¯æ¶ˆæ¯
Ok(api_error!("å·¥ä½œåŒºåç§°ä¸èƒ½ä¸ºç©º"))
Ok(ApiResponse::error("Workspace name cannot be empty"))
```

### 2. å¸¦å‚æ•°çš„é”™è¯¯æ¶ˆæ¯ ğŸ“

**è§„èŒƒï¼š** æ”¯æŒå‚æ•°æ’å€¼çš„é”™è¯¯æ¶ˆæ¯ï¼Œæä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ã€‚

```rust
âœ… æ­£ç¡®åšæ³•ï¼š
// åœ¨ i18n æ–‡ä»¶ä¸­å®šä¹‰å¸¦å‚æ•°çš„æ¶ˆæ¯
{
  "ai": {
    "test_connection_error": "è¿æ¥æµ‹è¯•å¤±è´¥: {error}"
  }
}

// åœ¨ä»£ç ä¸­ä½¿ç”¨å‚æ•°
Ok(api_error!("ai.test_connection_error", "error" => e.to_string()))

// ä½¿ç”¨ t! å®è¿›è¡Œæ–‡æœ¬å›½é™…åŒ–
let message = t!("ai.test_connection_error", "error" => "ç½‘ç»œè¶…æ—¶");
```

### 3. é”™è¯¯æ¶ˆæ¯åˆ†ç±» ğŸ·ï¸

**è§„èŒƒï¼š** æŒ‰æ¨¡å—å’ŒåŠŸèƒ½å¯¹é”™è¯¯æ¶ˆæ¯è¿›è¡Œåˆ†ç±»ï¼Œä¾¿äºç®¡ç†å’Œç»´æŠ¤ã€‚

```rust
âœ… æ­£ç¡®çš„åˆ†ç±»ç»“æ„ï¼š
{
  "common": {
    "operation_failed": "æ“ä½œå¤±è´¥",
    "invalid_params": "å‚æ•°æ— æ•ˆ",
    "not_found": "èµ„æºä¸å­˜åœ¨"
  },
  "storage": {
    "workspace_name_empty": "å·¥ä½œåŒºåç§°ä¸èƒ½ä¸ºç©º",
    "build_index_failed": "ç´¢å¼•æ„å»ºå¤±è´¥"
  },
  "ai": {
    "model_not_found": "æ¨¡å‹ä¸å­˜åœ¨",
    "api_key_empty": "API Keyä¸èƒ½ä¸ºç©º"
  }
}
```

## æ¨¡å—çº§é”™è¯¯å¤„ç†è§„èŒƒ

### 1. ç»Ÿä¸€çš„å¯¼å…¥å£°æ˜ ğŸ“¦

**è§„èŒƒï¼š** æ¯ä¸ªæ¨¡å—çš„é”™è¯¯å¤„ç†å¯¼å…¥å¿…é¡»æ ‡å‡†åŒ–ã€‚

```rust
âœ… æ­£ç¡®åšæ³•ï¼š
// åœ¨é”™è¯¯å®šä¹‰æ¨¡å— (error.rs)
use thiserror::Error;

// åœ¨ Tauri å‘½ä»¤æ¨¡å—é¡¶éƒ¨
use crate::module::error::{ModuleError, ModuleResult};
use crate::utils::{ApiResponse, EmptyData, TauriApiResult};
use crate::{api_error, api_success, t};
use tracing::{debug, error, info, warn};

// åœ¨ä¸šåŠ¡é€»è¾‘æ¨¡å—é¡¶éƒ¨
use crate::module::error::{ModuleError, ModuleResult};
use tracing::{debug, error, info, warn};
```

### 2. é”™è¯¯å¤„ç†å‡½æ•°å‘½å ğŸ·ï¸

**è§„èŒƒï¼š** é”™è¯¯å¤„ç†ç›¸å…³çš„å‡½æ•°å¿…é¡»ä½¿ç”¨æ¸…æ™°çš„å‘½åã€‚

```rust
âœ… æ­£ç¡®åšæ³•ï¼š
pub async fn validate_config(config: &AppConfig) -> Result<()>
pub async fn ensure_directory_exists(path: &Path) -> Result<()>
pub async fn handle_network_timeout() -> Result<()>

âŒ é”™è¯¯åšæ³•ï¼š
pub async fn check(config: &AppConfig) -> Result<()>  // å‘½åä¸æ¸…æ™°
pub async fn do_work() -> Result<()>                 // å‘½åä¸æ˜ç¡®
```

### 3. å‚æ•°éªŒè¯è§„èŒƒ âœ…

**è§„èŒƒï¼š** åœ¨ Tauri å‘½ä»¤ä¸­ä½¿ç”¨ç®€å•çš„æ¡ä»¶æ£€æŸ¥ï¼Œåœ¨ä¸šåŠ¡é€»è¾‘ä¸­ç›´æ¥è¿”å›é”™è¯¯å˜ä½“ã€‚

```rust
âœ… æ­£ç¡®åšæ³•ï¼ˆTauri å‘½ä»¤å±‚ï¼‰ï¼š
#[tauri::command]
pub async fn delete_workspace_index(id: i32) -> TauriApiResult<EmptyData> {
    // ç®€å•å‚æ•°éªŒè¯
    if id <= 0 {
        return Ok(api_error!("storage.invalid_workspace_id"));
    }

    // è°ƒç”¨ä¸šåŠ¡é€»è¾‘
    match workspace_service.delete_index(id).await {
        Ok(_) => Ok(api_success!()),
        Err(e) => {
            error!("Failed to delete workspace index: {:?}", e);
            
            // æ ¹æ®é”™è¯¯ç±»å‹è¿”å›ä¸åŒæ¶ˆæ¯
            let error_key = match e {
                StorageError::NotFound(_) => "storage.not_found",
                _ => "storage.delete_failed",
            };
            
            Ok(api_error!(error_key))
        }
    }
}

âœ… æ­£ç¡®åšæ³•ï¼ˆä¸šåŠ¡é€»è¾‘å±‚ï¼‰ï¼š
#[derive(Error, Debug)]
pub enum WorkspaceError {
    #[error("Workspace name cannot be empty")]
    NameEmpty,
    
    #[error("Workspace path does not exist: {0}")]
    PathNotExist(PathBuf),
    
    #[error("Invalid workspace data")]
    InvalidData,
}

pub fn validate_workspace_config(config: &WorkspaceConfig) -> Result<(), WorkspaceError> {
    if config.name.trim().is_empty() {
        return Err(WorkspaceError::NameEmpty);
    }
    
    if !config.path.exists() {
        return Err(WorkspaceError::PathNotExist(config.path.clone()));
    }
    
    Ok(())
}

pub fn process_workspace_data(data: &str) -> Result<ProcessedData, WorkspaceError> {
    if data.is_empty() {
        return Err(WorkspaceError::InvalidData);
    }
    // å¤„ç†é€»è¾‘...
    Ok(processed_data)
}

âŒ é”™è¯¯åšæ³•ï¼š
// ä¸è¦ä½¿ç”¨ anyhow çš„ bail! æˆ– ensure!
pub fn validate_config(config: &Config) -> anyhow::Result<()> {
    ensure!(!config.name.is_empty(), "åç§°ä¸èƒ½ä¸ºç©º");  // é”™è¯¯ï¼šä½¿ç”¨ anyhow
    Ok(())
}
```

## é”™è¯¯çº§åˆ«å’Œæ—¥å¿—è§„èŒƒ

### 1. é”™è¯¯æ—¥å¿—çº§åˆ« ğŸ“Š

**è§„èŒƒï¼š** æ ¹æ®é”™è¯¯çš„ä¸¥é‡ç¨‹åº¦é€‰æ‹©åˆé€‚çš„æ—¥å¿—çº§åˆ«ã€‚

```rust
âœ… æ­£ç¡®åšæ³•ï¼š
// ç³»ç»Ÿçº§é”™è¯¯ - error!
if let Err(e) = critical_system_operation() {
    tracing::error!("ç³»ç»Ÿæ“ä½œå¤±è´¥: {:?}", e);
    return Err(e);
}

// ä¸šåŠ¡çº§é”™è¯¯ - warn!
if let Err(e) = validate_user_input(&input) {
    tracing::warn!("ç”¨æˆ·è¾“å…¥éªŒè¯å¤±è´¥: {}", e);
    return Err(e);
}

// å¯æ¢å¤é”™è¯¯ - info!
if let Err(e) = optional_operation() {
    tracing::info!("å¯é€‰æ“ä½œå¤±è´¥ï¼Œç»§ç»­æ‰§è¡Œ: {}", e);
    // ç»§ç»­æ‰§è¡Œå…¶ä»–é€»è¾‘
}
```

### 2. ç»“æ„åŒ–é”™è¯¯æ—¥å¿— ğŸ—ï¸

**è§„èŒƒï¼š** ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—è®°å½•é”™è¯¯ä¿¡æ¯ã€‚

```rust
âœ… æ­£ç¡®åšæ³•ï¼š
tracing::error!(
    error = %error,
    module = "config",
    operation = "load_config",
    path = %config_path,
    "é…ç½®åŠ è½½å¤±è´¥"
);
```

## æµ‹è¯•ä¸­çš„é”™è¯¯å¤„ç†è§„èŒƒ

### 1. æµ‹è¯•é”™è¯¯åœºæ™¯ ğŸ§ª

**è§„èŒƒï¼š** æ¯ä¸ªå¯èƒ½å¤±è´¥çš„å‡½æ•°éƒ½å¿…é¡»æœ‰å¯¹åº”çš„é”™è¯¯æµ‹è¯•ã€‚

```rust
âœ… æ­£ç¡®åšæ³•ï¼š
#[tokio::test]
async fn test_load_config_file_not_found() {
    let result = load_config("non_existent.toml").await;
    assert!(result.is_err());

    let error = result.unwrap_err();
    assert!(error.to_string().contains("è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥"));
}

#[tokio::test]
async fn test_load_config_invalid_format() {
    // åˆ›å»ºæ— æ•ˆçš„é…ç½®æ–‡ä»¶
    let invalid_content = "invalid toml content";
    fs::write("test_invalid.toml", invalid_content).await.unwrap();

    let result = load_config("test_invalid.toml").await;
    assert!(result.is_err());

    let error = result.unwrap_err();
    assert!(error.to_string().contains("è§£æé…ç½®æ–‡ä»¶å¤±è´¥"));
}
```

## æ–‡æ¡£è§„èŒƒ

### 1. å‡½æ•°æ–‡æ¡£ ğŸ“š

**è§„èŒƒï¼š** æ‰€æœ‰å¯èƒ½å¤±è´¥çš„å‡½æ•°å¿…é¡»åœ¨æ–‡æ¡£ä¸­è¯´æ˜é”™è¯¯æ¡ä»¶ã€‚

````rust
âœ… æ­£ç¡®åšæ³•ï¼š
/// åŠ è½½åº”ç”¨ç¨‹åºé…ç½®
///
/// # é”™è¯¯
///
/// åœ¨ä»¥ä¸‹æƒ…å†µä¸‹ä¼šè¿”å›é”™è¯¯ï¼š
/// - é…ç½®æ–‡ä»¶ä¸å­˜åœ¨
/// - é…ç½®æ–‡ä»¶æ ¼å¼æ— æ•ˆ
/// - é…ç½®æ–‡ä»¶æƒé™ä¸è¶³
///
/// # ç¤ºä¾‹
///
/// ```rust
/// let config = load_config().await?;
/// ```
pub async fn load_config() -> Result<AppConfig> {
    // å®ç°
}
````

### 2. é”™è¯¯ä¿¡æ¯è§„èŒƒ ğŸ’¬

**è§„èŒƒï¼š** é”™è¯¯ä¿¡æ¯å¿…é¡»æ¸…æ™°ã€å¯æ“ä½œï¼Œå¹¶æä¾›è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡ã€‚

| é”™è¯¯ç±»å‹ | ä¿¡æ¯æ ¼å¼                          | ç¤ºä¾‹                                                  |
| -------- | --------------------------------- | ----------------------------------------------------- |
| æ–‡ä»¶æ“ä½œ | "æ“ä½œå¤±è´¥: æ–‡ä»¶è·¯å¾„ (åŸå› )"       | "è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥: /path/to/config.toml (æ–‡ä»¶ä¸å­˜åœ¨)" |
| ç½‘ç»œè¯·æ±‚ | "ç½‘ç»œæ“ä½œå¤±è´¥: URL (çŠ¶æ€ç /åŸå› )" | "APIè¯·æ±‚å¤±è´¥: <https://api.example.com> (è¶…æ—¶)"       |
| æ•°æ®éªŒè¯ | "éªŒè¯å¤±è´¥: å­—æ®µå (å…·ä½“åŸå› )"     | "å‚æ•°éªŒè¯å¤±è´¥: email (æ ¼å¼æ— æ•ˆ)"                      |

## å‰ç«¯é”™è¯¯å¤„ç†è§„èŒƒ

### 1. Vue ç»„ä»¶é”™è¯¯å¤„ç† ğŸ–¥ï¸

**è§„èŒƒï¼š** å‰ç«¯ç»„ä»¶åº”ä¼˜é›…å¤„ç† API é”™è¯¯ï¼Œæä¾›ç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤ºã€‚

```typescript
âœ… æ­£ç¡®åšæ³•ï¼š
// åœ¨ Vue ç»„ä»¶ä¸­å¤„ç† API é”™è¯¯
const handleBuildWorkspaceIndex = async () => {
  const canBuild = !hasWorkspaceIndex.value &&
    currentWorkspaceIndex.value?.status !== IndexStatus.Building

  if (!canBuild) {
    console.warn('å·¥ä½œåŒºç´¢å¼•å·²å­˜åœ¨æˆ–æ­£åœ¨æ„å»ºï¼Œè·³è¿‡æ“ä½œ')
    return
  }

  try {
    // å¦‚æœå·²æœ‰errorçŠ¶æ€çš„ç´¢å¼•ï¼Œå…ˆåˆ é™¤
    if (currentWorkspaceIndex.value?.status === IndexStatus.Error &&
        currentWorkspaceIndex.value?.id) {
      await workspaceIndexApi.deleteWorkspace(currentWorkspaceIndex.value.id)
    }

    const workspace = await workspaceIndexApi.buildWorkspaceIndex({
      path: currentPath,
      name: directoryName,
    })

    currentWorkspaceIndex.value = workspace
    startBuildStatusPolling() // å¼€å§‹è½®è¯¢æ„å»ºçŠ¶æ€
  } catch (error) {
    console.error('æ„å»ºå·¥ä½œåŒºç´¢å¼•å¤±è´¥:', error)
    // é”™è¯¯å¤„ç†ç”± store æˆ– API å±‚å¤„ç†ï¼Œç»„ä»¶å±‚ä¸»è¦è´Ÿè´£UIçŠ¶æ€æ›´æ–°
  }
}

âŒ é”™è¯¯åšæ³•ï¼š
// ä¸è¦å¿½ç•¥é”™è¯¯æˆ–åªæ˜¯ç®€å•æ‰“å°
const handleBuildIndex = async () => {
  const result = await buildIndex()
  // æ²¡æœ‰é”™è¯¯å¤„ç†ï¼Œæ²¡æœ‰çŠ¶æ€ç®¡ç†
}
```

### 2. API å“åº”å¤„ç† ğŸ“¡

**è§„èŒƒï¼š** å‰ç«¯åº”æ­£ç¡®è§£æ `ApiResponse` ç»“æ„ï¼Œæ ¹æ® `code` å­—æ®µåˆ¤æ–­æ“ä½œç»“æœã€‚

```typescript
âœ… æ­£ç¡®åšæ³•ï¼š
interface ApiResponse<T> {
  code: number
  message?: string
  data?: T
}
```

### 2. API è°ƒç”¨è§„èŒƒ ğŸ”Œ

**è§„èŒƒï¼š** å‰ç«¯é€šè¿‡ API æœåŠ¡å±‚è°ƒç”¨æ¥å£ï¼Œä¸åœ¨ç»„ä»¶ä¸­ç›´æ¥ä½¿ç”¨ `invoke` å‡½æ•°ã€‚

```typescript
âœ… æ­£ç¡®åšæ³•ï¼š
// API æœåŠ¡å±‚ - /src/api/workspace-index/index.ts
import { invoke } from '@/utils/request'

export class CkApi {
  async buildWorkspaceIndex(params: BuildWorkspaceIndexParams): Promise<WorkspaceIndex> {
    return await invoke<WorkspaceIndex>('workspace_build_index', {
      request: {
        path: params.path,
        name: params.name,
      },
    })
  }

  async checkCurrentWorkspace(): Promise<WorkspaceIndex | null> {
    return await invoke<WorkspaceIndex | null>('workspace_check_current_index')
  }
}

export const workspaceIndexApi = new CkApi()

// ç»„ä»¶ä¸­ä½¿ç”¨ - é€šè¿‡ API æœåŠ¡å±‚
import { workspaceIndexApi } from '@/api/workspace-index'

const buildWorkspaceIndex = async () => {
  try {
    const workspaceIndex = await workspaceIndexApi.buildWorkspaceIndex({
      path: workspacePath.value,
      name: workspaceName.value
    })

    currentWorkspaceIndex.value = workspaceIndex
  } catch (error) {
    // é”™è¯¯å·²åœ¨ invoke å±‚ç»Ÿä¸€å¤„ç†å’Œæ˜¾ç¤º
    console.error('æ„å»ºå·¥ä½œåŒºç´¢å¼•å¤±è´¥:', error)
  }
}

âŒ é”™è¯¯åšæ³•ï¼š
// ä¸è¦åœ¨ç»„ä»¶ä¸­ç›´æ¥ä½¿ç”¨ invoke
import { invoke } from '@/utils/request'

const buildIndex = async () => {
  try {
    // é”™è¯¯ï¼šç»„ä»¶ä¸åº”è¯¥ç›´æ¥è°ƒç”¨ invoke
    const workspaceIndex = await invoke<WorkspaceIndex>('workspace_build_index', { request })
    return workspaceIndex
  } catch (error) {
    console.error(error)
    throw error
  }
}
```

### 3. é”™è¯¯æ¶ˆæ¯æ˜¾ç¤º ğŸŒ

**è§„èŒƒï¼š** ç»Ÿä¸€çš„ `invoke` å‡½æ•°å·²è‡ªåŠ¨å¤„ç†é”™è¯¯æç¤ºï¼Œç»„ä»¶é€šè¿‡ API æœåŠ¡å±‚è°ƒç”¨ï¼Œæ— éœ€é¢å¤–çš„é”™è¯¯æ¶ˆæ¯å¤„ç†ã€‚

````vue
<script setup lang="ts">
  import { workspaceIndexApi } from '@/api/workspace-index'

  // API è°ƒç”¨ç¤ºä¾‹ - é€šè¿‡ API æœåŠ¡å±‚
  const buildWorkspaceIndex = async () => {
    try {
      // API æœåŠ¡å±‚å†…éƒ¨ä½¿ç”¨ invoke å‡½æ•°ï¼Œå·²å¤„ç†ï¼š
      // 1. è§£æ ApiResponse<T> ç»“æ„
      // 2. å¤±è´¥æ—¶è°ƒç”¨ createMessage.error() æ˜¾ç¤ºé”™è¯¯
      // 3. æˆåŠŸæ—¶ç›´æ¥è¿”å› data
      const workspaceIndex = await workspaceIndexApi.buildWorkspaceIndex({
        path: workspacePath.value,
        name: workspaceName.value,
      })

      // ç›´æ¥ä½¿ç”¨è¿”å›çš„æ•°æ®
      currentWorkspaceIndex.value = workspaceIndex
    } catch (error) {
      // é”™è¯¯æç¤ºå·²åœ¨ invoke å±‚è‡ªåŠ¨æ˜¾ç¤º
      // è¿™é‡Œåªéœ€è¦å¤„ç† UI çŠ¶æ€æˆ–ä¸šåŠ¡é€»è¾‘
      console.error('æ„å»ºå·¥ä½œåŒºç´¢å¼•å¤±è´¥:', error)
    }
  }
</script>

<template>
  <!-- å·¥ä½œåŒºç´¢å¼•çŠ¶æ€æ˜¾ç¤º -->
  <div v-if="hasWorkspaceIndex" class="index-status">
    {{ t('storage.index_ready') }}
  </div>

  <div v-else-if="currentWorkspaceIndex?.status === IndexStatus.Building" class="building-status">
    {{ t('storage.building_workspace_index') }}
  </div>

  <div v-else-if="isIndexInError" class="error-status">
    {{ t('storage.index_error') }}
  </div>

  <!-- æ— éœ€æ‰‹åŠ¨æ˜¾ç¤ºé”™è¯¯ - ç»Ÿä¸€å±‚å·²å¤„ç† -->
</template>

âŒ é”™è¯¯åšæ³•ï¼š ```vue
<script setup lang="ts">
  // ä¸è¦åœ¨ç»„ä»¶ä¸­ç›´æ¥ä½¿ç”¨ invoke
  import { invoke } from '@/utils/request'

  const buildWorkspaceIndex = async () => {
    try {
      // é”™è¯¯ï¼šç»„ä»¶ä¸åº”è¯¥ç›´æ¥è°ƒç”¨ invoke
      const workspaceIndex = await invoke<WorkspaceIndex>('workspace_build_index', { request })
      currentWorkspaceIndex.value = workspaceIndex
    } catch (error) {
      console.error(error)
    }
  }

  // ä¸è¦æ‰‹åŠ¨å¤„ç† ApiResponse ç»“æ„
  const buildIndex = async () => {
    try {
      const response = await api.invoke<ApiResponse<WorkspaceIndex>>('workspace_build_index', { request })

      if (response.code === 200 && response.data) {
        // é”™è¯¯ï¼šæ‰‹åŠ¨å¤„ç†å“åº”ç»“æ„ï¼Œåº”è¯¥è®© API æœåŠ¡å±‚å¤„ç†
        currentWorkspaceIndex.value = response.data
      } else {
        throw new Error(response.message || 'æ“ä½œå¤±è´¥')
      }
    } catch (error) {
      handleApiError(error as Error)
    }
  }
</script>
````

### 4. é”™è¯¯çŠ¶æ€ç®¡ç† ğŸ“Š

**è§„èŒƒï¼š** ä½¿ç”¨å“åº”å¼çŠ¶æ€ç®¡ç†é”™è¯¯ä¿¡æ¯ï¼Œæä¾›ä¸€è‡´çš„ç”¨æˆ·ä½“éªŒã€‚

```typescript
âœ… æ­£ç¡®åšæ³•ï¼š
// åœ¨ç»„ä»¶ä¸­ç®¡ç†é”™è¯¯çŠ¶æ€
const currentWorkspaceIndex = ref<WorkspaceIndex | null>(null)
const isLoading = ref(false)
const errorState = ref<{
  hasError: boolean
  message: string
  type: 'network' | 'validation' | 'system' | null
}>({
  hasError: false,
  message: '',
  type: null
})

// è®¡ç®—å±æ€§ç”¨äºUIçŠ¶æ€åˆ¤æ–­
const hasWorkspaceIndex = computed(() => {
  return currentWorkspaceIndex.value?.status === IndexStatus.Ready
})

const isIndexInError = computed(() => {
  return currentWorkspaceIndex.value?.status === IndexStatus.Error
})

const canBuildIndex = computed(() => {
  return !hasWorkspaceIndex.value &&
         currentWorkspaceIndex.value?.status !== IndexStatus.Building &&
         !isLoading.value
})
```

## ä»£ç å®¡æŸ¥æ¸…å•

åœ¨æäº¤ä»£ç å‰ï¼Œè¯·ç¡®è®¤ä»¥ä¸‹äº‹é¡¹ï¼š

### åç«¯ Rust ä»£ç 

- [ ] æ¯ä¸ªæ¨¡å—ä½¿ç”¨ `thiserror` å®šä¹‰è‡ªå·±çš„ Error æšä¸¾
- [ ] å®šä¹‰äº† `type ModuleResult<T> = Result<T, ModuleError>` åˆ«å
- [ ] å¤–éƒ¨é”™è¯¯ä½¿ç”¨ `#[from]` å±æ€§è‡ªåŠ¨è½¬æ¢
- [ ] æŠ€æœ¯é”™è¯¯æ¶ˆæ¯ä½¿ç”¨è‹±æ–‡ï¼ˆåœ¨ `#[error]` ä¸­ï¼‰
- [ ] Tauri å‘½ä»¤è¿”å› `TauriApiResult<T>` ç±»å‹
- [ ] ä½¿ç”¨ `api_error!` å’Œ `api_success!` å®
- [ ] ç”¨æˆ·é”™è¯¯æ¶ˆæ¯ä½¿ç”¨ i18n key è€Œä¸æ˜¯ç¡¬ç¼–ç æ–‡æœ¬
- [ ] é”™è¯¯æ¶ˆæ¯å·²åœ¨ `zh-CN.json` å’Œ `en-US.json` ä¸­å®šä¹‰
- [ ] ä½¿ç”¨é€‚å½“çš„æ—¥å¿—çº§åˆ«è®°å½•é”™è¯¯ï¼ˆerror!, warn!, info!ï¼‰
- [ ] å‚æ•°éªŒè¯åœ¨ Tauri å‘½ä»¤å±‚ä½¿ç”¨ç®€å•æ¡ä»¶æ£€æŸ¥
- [ ] ä¸šåŠ¡é€»è¾‘å±‚ç›´æ¥è¿”å›é”™è¯¯å˜ä½“
- [ ] é”™è¯¯åˆ†ç±»ä½¿ç”¨æ¨¡å¼åŒ¹é…è€Œä¸æ˜¯å­—ç¬¦ä¸²åŒ¹é…
- [ ] ä¸å†ä½¿ç”¨ `.into()` è¿›è¡Œé”™è¯¯è½¬æ¢ï¼ˆé™¤éå¿…è¦ï¼‰
- [ ] æ·»åŠ äº†å¿…è¦çš„é”™è¯¯æµ‹è¯•ç”¨ä¾‹

### å‰ç«¯ Vue.js ä»£ç 

- [ ] é€šè¿‡ API æœåŠ¡å±‚è°ƒç”¨æ¥å£ï¼Œä¸åœ¨ç»„ä»¶ä¸­ç›´æ¥ä½¿ç”¨ `invoke`
- [ ] API æœåŠ¡å±‚æ­£ç¡®ä½¿ç”¨ `invoke` å‡½æ•°å¤„ç† `ApiResponse<T>` ç»“æ„
- [ ] ç»„ä»¶ä¸­åªå¤„ç†ä¸šåŠ¡é€»è¾‘å’Œ UI çŠ¶æ€ï¼Œä¸å¤„ç†é”™è¯¯æ¶ˆæ¯æ˜¾ç¤º
- [ ] é”™è¯¯æç¤ºå·²åœ¨ `invoke` å±‚ç»Ÿä¸€å¤„ç†ï¼Œæ— éœ€é‡å¤å¤„ç†
- [ ] é”™è¯¯çŠ¶æ€é€šè¿‡å“åº”å¼æ•°æ®ç®¡ç†
- [ ] è®¡ç®—å±æ€§ç”¨äº UI çŠ¶æ€åˆ¤æ–­
- [ ] å¼‚æ­¥æ“ä½œæœ‰é€‚å½“çš„åŠ è½½çŠ¶æ€ç®¡ç†

## å¸¸è§åæ¨¡å¼

### âŒ é¿å…è¿™äº›åšæ³•

1. **ä½¿ç”¨ anyhow::Result è€Œä¸æ˜¯ç»“æ„åŒ–é”™è¯¯**

   ```rust
   // âŒ ä¸è¦è¿™æ ·åš
   use anyhow::Result;
   
   pub async fn load_data() -> Result<Data> {
       // é”™è¯¯ï¼šæ— æ³•åŒºåˆ†é”™è¯¯ç±»å‹
   }
   
   // âœ… åº”è¯¥è¿™æ ·åš
   use thiserror::Error;
   
   #[derive(Error, Debug)]
   pub enum DataError {
       #[error("Not found: {0}")]
       NotFound(String),
   }
   
   pub async fn load_data() -> Result<Data, DataError> {
       // æ­£ç¡®ï¼šå¯ä»¥æ¨¡å¼åŒ¹é…é”™è¯¯ç±»å‹
   }
   ```

2. **æ‰‹åŠ¨é”™è¯¯è½¬æ¢ï¼ˆå½“æœ‰ `#[from]` æ—¶ï¼‰**

   ```rust
   // âŒ ä¸è¦è¿™æ ·åš
   .map_err(|e| MyError::IoError(e))?  // å¤šä½™ï¼
   
   // âœ… åº”è¯¥è¿™æ ·åšï¼ˆå®šä¹‰æ—¶ç”¨ #[from]ï¼‰
   #[derive(Error, Debug)]
   pub enum MyError {
       #[error("IO error: {0}")]
       IoError(#[from] std::io::Error),
   }
   
   // ç„¶åç›´æ¥ç”¨ ?
   let content = fs::read_to_string(path)?;
   ```

3. **é”™è¯¯ä¿¡æ¯ä½¿ç”¨ä¸­æ–‡**

   ```rust
   // âŒ ä¸è¦è¿™æ ·åš
   #[error("æ–‡ä»¶ä¸å­˜åœ¨")]  // æŠ€æœ¯é”™è¯¯åº”è¯¥ç”¨è‹±æ–‡
   
   // âœ… åº”è¯¥è¿™æ ·åš
   #[error("File not found: {0}")]  // è‹±æ–‡ï¼Œä¾›å¼€å‘è€…çœ‹
   ```

4. **ç›´æ¥ä½¿ç”¨ unwrap()**

   ```rust
   // âŒ ä¸è¦è¿™æ ·åš
   let result = operation().unwrap(); // å¯èƒ½å¼•èµ· panic
   
   // âœ… åº”è¯¥è¿™æ ·åš
   let result = operation()?; // è¿”å›é”™è¯¯ç»™è°ƒç”¨è€…
   ```

5. **è¿”å› String ç±»å‹çš„é”™è¯¯**

   ```rust
   // âŒ ä¸è¦è¿™æ ·åš
   Err("æ“ä½œå¤±è´¥".to_string())
   
   // âœ… åº”è¯¥è¿™æ ·åš
   Err(MyError::OperationFailed)
   ```

6. **ä¸ä½¿ç”¨ `#[from]` è‡ªåŠ¨è½¬æ¢**

   ```rust
   // âŒ ä¸è¦è¿™æ ·åš
   #[derive(Error, Debug)]
   pub enum MyError {
       #[error("IO error: {0}")]
       IoError(std::io::Error),  // ç¼ºå°‘ #[from]
   }
   
   // âœ… åº”è¯¥è¿™æ ·åš
   #[derive(Error, Debug)]
   pub enum MyError {
       #[error("IO error: {0}")]
       IoError(#[from] std::io::Error),  // æœ‰ #[from]
   }
   ```

## ä»£ç å®¡æŸ¥æ¸…å•è¡¥å……

### é”™è¯¯ç±»å‹è®¾è®¡

- [ ] æ¯ä¸ªæ¨¡å—å®šä¹‰äº†è‡ªå·±çš„ Error æšä¸¾ï¼ˆä½¿ç”¨ thiserrorï¼‰
- [ ] é”™è¯¯æšä¸¾æœ‰ `type ModuleResult<T> = Result<T, ModuleError>` åˆ«å
- [ ] å¤–éƒ¨é”™è¯¯ä½¿ç”¨ `#[from]` è‡ªåŠ¨è½¬æ¢
- [ ] é”™è¯¯æ¶ˆæ¯ä½¿ç”¨è‹±æ–‡
- [ ] é”™è¯¯å˜ä½“è¶³å¤Ÿå…·ä½“ï¼Œå¯ä»¥åŒºåˆ†ä¸åŒæƒ…å†µ

é€šè¿‡éµå¾ªè¿™äº›è§„èŒƒï¼Œæˆ‘ä»¬å¯ä»¥ç¡®ä¿ OrbitX é¡¹ç›®ä¸­çš„é”™è¯¯å¤„ç†ä¿æŒä¸€è‡´æ€§ã€å¯ç»´æŠ¤æ€§å’Œç”¨æˆ·å‹å¥½æ€§ã€‚
