# 文件结构开发规范

## 概述

本文档定义了 OrbitX 项目中文件组织和模块结构的开发标准。所有开发者在创建新文件、模块或重构现有代码时必须遵循本规范，以确保代码库的一致性和可维护性。

**版本**: v2.1  
**更新**: 2024年12月 - 加入统一重构标准和过度拆分避免原则

## 核心原则

### 1. 文件夹优于文件名前缀 📁

**规范：** 使用目录结构而非文件名前缀来组织相关功能。

```text
✅ 正确做法：
src/terminal/commands/
├── mod.rs          # 统一导出，共享类型
├── pane.rs         # 面板管理命令
├── context.rs      # 上下文管理命令
├── cache.rs        # 缓存管理命令
└── stats.rs        # 统计信息命令

❌ 错误做法：
src/terminal/
├── pane_commands.rs
├── context_commands.rs
├── cache_commands.rs
└── stats_commands.rs
```

**说明：** 文件夹结构能更清晰地表达代码的组织关系，便于理解和维护。

### 2. 按功能域组织模块 🎯

**规范：** 模块划分必须基于功能域而非技术分层。

```text
✅ 正确做法：
src/
├── ai/              # AI 功能域
│   ├── commands/    # AI 命令
│   ├── context/     # AI 上下文
│   └── service/     # AI 服务
├── config/          # 配置功能域
│   ├── theme/       # 主题配置
│   └── shortcuts/   # 快捷键配置
└── terminal/        # 终端功能域
    ├── commands/    # 终端命令
    └── context/     # 终端上下文

❌ 错误做法：
src/
├── commands/        # 技术分层（所有命令混在一起）
│   ├── ai_commands.rs
│   ├── config_commands.rs
│   └── terminal_commands.rs
├── services/        # 技术分层（所有服务混在一起）
│   ├── ai_service.rs
│   └── config_service.rs
└── types/           # 技术分层（所有类型混在一起）
    ├── ai_types.rs
    └── config_types.rs
```

### 3. 统一重构标准 ⭐ **关键原则**

**规范：** 同类型文件必须遵循统一的重构标准，避免不同模块使用不同的拆分方式。

| 文件类型            | 拆分方式       | 适用条件             | 示例                      |
| ------------------- | -------------- | -------------------- | ------------------------- |
| `**/commands.rs`    | 按功能域拆分   | 多功能域，收益明显   | `terminal/commands/`      |
| `**/manager.rs`     | 按管理职责拆分 | 评估耦合度后决定     | `config/toml/`            |
| `**/*_generator.rs` | 按技术实现拆分 | 多技术实现，拆分合理 | `shell/script_generator/` |
| `**/types.rs`       | ❌ 不建议拆分  | 类型定义，保持内聚   | 保持现状                  |

### 4. 避免过度拆分 ⚠️ **重要原则**

**规范：** 不是所有大文件都需要拆分，重构前必须评估收益与成本。

#### 🚫 不应拆分的情况

- **纯类型定义文件** (`**/types.rs`)
  - 主要包含结构体、枚举、trait定义
  - 类型之间有强关联性，拆分会破坏内聚性
  - 示例：`completion/types.rs`, `mux/types.rs`, `terminal/types.rs`

- **单一职责的实现文件**
  - 虽然行数多但功能单一
  - 拆分后反而增加理解复杂度
  - 示例：数据库连接、HTTP客户端实现

- **核心系统组件**
  - 高度集成的系统核心组件
  - 涉及复杂的多线程同步或状态管理
  - 拆分可能引入新的同步问题
  - 示例：`mux/terminal_mux.rs` - 终端多路复用器核心

#### ✅ 应当拆分的情况

- **多功能域混合的文件**
  - 包含明显不同的功能域
  - 可以清晰地按功能分离
  - 示例：`commands.rs` (包含多种命令类型)

- **按技术实现可分的文件**
  - 为不同平台/技术提供相同功能
  - 可以按实现方式清晰分离
  - 示例：`script_generator.rs` (bash, zsh, fish等)

- **超大文件且职责复杂**
  - 800行以上且包含多个职责
  - 难以一次性理解全部逻辑
  - 修改时经常涉及多个不相关的部分

#### 📊 拆分评估标准

```
重构收益 = (可维护性提升 + 可读性提升 + 并行开发便利) - (拆分成本 + 学习成本 + 维护成本)

收益 > 0 → 建议重构
收益 ≤ 0 → 保持现状
```

**评估维度**：

- **功能域数量**：≥3个不同功能域 → 建议拆分
- **文件类型**：Commands/Manager类 → 优先拆分，Types类 → 谨慎拆分
- **内聚程度**：低内聚 → 建议拆分，高内聚 → 保持现状
- **修改频率**：经常同时修改不相关部分 → 建议拆分

### 5. 控制文件大小 📏

**规范：** 每个文件必须保持适当的大小，确保可读性和可维护性。

| 文件类型                     | 建议行数 | 强制上限 | 拆分阈值 |
| ---------------------------- | -------- | -------- | -------- |
| 主入口文件 (lib.rs, main.rs) | < 400 行 | 500 行   | 500 行   |
| 功能模块文件                 | < 500 行 | 600 行   | 800 行   |
| 工具/辅助模块                | < 300 行 | 400 行   | 500 行   |
| mod.rs 文件                  | < 300 行 | 400 行   | 400 行   |

## 统一重构模式

### 🔧 标准拆分模式

#### 1. Commands类文件 (`**/commands.rs`)

**统一按功能域拆分**：

```
模块名/commands/
├── mod.rs           # 统一导出，共享类型，状态管理
├── [主功能域].rs    # 主要功能域（如：pane, context, cache）
├── [次功能域].rs    # 次要功能域（如：stats, platform）
├── [辅助域].rs      # 辅助功能域（如：utils, helpers）
└── [工具域].rs      # 工具功能域（如：directory, opacity）
```

**实际案例**：

```
terminal/commands/     # ✅ 已重构
├── mod.rs          (120行) - 共享类型，状态管理
├── pane.rs         (175行) - 面板管理命令
├── context.rs      (155行) - 上下文管理命令
├── cache.rs        (95行)  - 缓存管理命令
└── stats.rs        (85行)  - 统计信息命令
```

#### 2. Generator/Service类文件 (`**/*_generator.rs`, `**/*_service.rs`)

**统一按技术实现拆分**：

```
模块名/功能名/
├── mod.rs           # 统一导出，主入口，共享配置
├── [技术1].rs       # 技术实现1（如：bash, http）
├── [技术2].rs       # 技术实现2（如：zsh, websocket）
├── [技术3].rs       # 技术实现3（如：fish, grpc）
└── [技术4].rs       # 技术实现4（如：powershell）
```

**实际案例**：

```
shell/script_generator/   # ✅ 已重构
├── mod.rs            (350行) - 统一导出，配置管理
├── bash.rs           (155行) - Bash脚本生成
├── zsh.rs            (130行) - Zsh脚本生成
├── fish.rs           (115行) - Fish脚本生成
└── powershell.rs     (140行) - PowerShell脚本生成
```

#### 3. Manager类文件 (`**/manager.rs`)

**统一按管理职责拆分**：

```
模块名/manager/
├── mod.rs           # 统一导出，核心管理器类型
├── core.rs          # 核心管理逻辑
├── reader.rs        # 读取功能
├── writer.rs        # 写入功能
├── validator.rs     # 验证功能
└── events.rs        # 事件处理
```

**实际案例**：

```
config/toml/        # ✅ 已重构，符合标准
├── mod.rs          # 统一导出
├── manager.rs      # 核心管理器
├── reader.rs       # 读取功能
├── writer.rs       # 写入功能
├── validator.rs    # 验证功能
└── events.rs       # 事件处理
```

## 模块组织规范

### 1. 模块结构标准 🏗️

**规范：** 每个功能模块必须遵循以下结构。

```text
// 基础模块结构
src/feature_name/
├── mod.rs          # 模块主文件，负责导出和状态管理
├── commands.rs     # Tauri 命令（如果适用）
├── types.rs        # 类型定义
├── service.rs      # 业务逻辑服务
└── utils.rs        # 辅助工具函数

// 复杂模块结构（需要进一步拆分时）
src/feature_name/
├── mod.rs
├── commands/       # 命令子模块（按功能域拆分）
│   ├── mod.rs
│   ├── [功能域1].rs
│   └── [功能域2].rs
├── types.rs        # 保持类型定义的内聚性
└── service/        # 服务子模块（按管理职责拆分）
    ├── mod.rs
    ├── core.rs
    └── cache.rs
```

### 2. mod.rs 文件规范 📋

**规范：** 每个 `mod.rs` 文件必须清晰地定义模块的对外接口。

```rust
✅ 正确做法：
// src/terminal/commands/mod.rs
/*!
 * 终端上下文管理 Tauri 命令接口
 *
 * 提供前端调用的终端上下文管理命令，包括：
 * - 面板管理
 * - 上下文查询
 * - 缓存管理
 * - 统计信息
 */

// 共享类型定义
pub struct TerminalContextState {
    pub registry: Arc<ActiveTerminalContextRegistry>,
    pub context_service: Arc<TerminalContextService>,
}

// 导出各功能域模块
pub mod pane;
pub mod context;
pub mod cache;
pub mod stats;

// 重新导出所有命令函数，保持向后兼容
pub use pane::{set_active_pane, get_active_pane, clear_active_pane, is_pane_active};
pub use context::{get_terminal_context, get_active_terminal_context};
pub use cache::{invalidate_context_cache, clear_all_context_cache};
pub use stats::{get_context_cache_stats, get_registry_stats};

❌ 错误做法：
// src/terminal/commands/mod.rs
pub mod pane;
pub mod context;
pub mod cache;
pub mod stats;

// 导出所有内容（缺乏控制）
pub use pane::*;
pub use context::*;
pub use cache::*;
pub use stats::*;
```

### 3. 命名规范 🏷️

**规范：** 文件和目录命名必须遵循一致的规则。

| 元素类型 | 命名规则             | 示例                                             |
| -------- | -------------------- | ------------------------------------------------ |
| 目录名   | snake_case，使用复数 | `commands/`, `repositories/`, `config_managers/` |
| 文件名   | snake_case，功能描述 | `pane.rs`, `context.rs`, `cache.rs`              |
| 模块名   | snake_case           | `mod terminal_commands;`                         |

```
✅ 正确做法：
src/
├── terminal/           # 功能域目录
│   ├── commands/       # 子功能目录
│   │   ├── pane.rs     # 功能描述清晰
│   │   └── context.rs  # 单一功能
│   └── context_service.rs
└── config/
    ├── toml/
    │   ├── reader.rs   # 按职责命名
    │   └── writer.rs   # 功能明确
    └── theme_config.rs

❌ 错误做法：
src/
├── Terminal/           # 不要使用大写
├── terminalCommands/   # 不要使用 camelCase
├── terminal-commands/  # 不要使用 kebab-case
└── TerminalCommand.rs  # 文件名不要使用 PascalCase
```

## 重构实施规范

### 1. 重构流程 🔄

**规范：** 执行重构时必须遵循以下步骤。

```
1. 📊 评估阶段
   - 分析文件大小和复杂度
   - 识别功能域数量
   - 评估重构收益
   - 确定拆分方式

2. 🏗️ 设计阶段
   - 设计目标模块结构
   - 确定模块间接口
   - 规划导入导出策略

3. ⚡ 实施阶段
   - 创建目标目录结构
   - 按功能域/技术实现拆分代码
   - 创建统一的mod.rs导出
   - 更新引用路径

4. ✅ 验证阶段
   - 编译检查通过
   - 功能测试通过
   - 确保向后兼容
   - 代码审查通过
```

### 2. 重构检查清单 ✔️

在完成重构后，请确认以下事项：

- [ ] 遵循统一的重构标准（Commands/Manager/Generator类文件）
- [ ] 编译检查通过
- [ ] 所有原有功能保持不变
- [ ] 文件大小符合标准（单文件 < 500行）
- [ ] 模块职责清晰，功能域明确分离
- [ ] 提供统一的mod.rs导出接口
- [ ] 保持向后兼容性
- [ ] 更新了相关的导入路径
- [ ] 添加了必要的模块文档

### 3. 重构示例参考 📖

#### 成功案例1: terminal/commands.rs → terminal/commands/

```
重构前：commands.rs (664行，功能混杂)
重构后：commands/ (5个模块，职责清晰)

收益：
✅ 功能域清晰分离（面板、上下文、缓存、统计）
✅ 单文件大小控制在200行以内
✅ 便于并行开发和维护
✅ 编译通过，功能完整
```

#### 成功案例2: shell/script_generator.rs → shell/script_generator/

```
重构前：script_generator.rs (771行，多技术实现混合)
重构后：script_generator/ (5个模块，按技术实现拆分)

收益：
✅ 技术实现清晰分离（bash、zsh、fish、powershell）
✅ 新增Shell支持更容易
✅ 每个技术实现独立维护
✅ 保持配置管理的统一性
```

#### 评估案例: config/shortcuts/actions.rs

```
评估结果：❌ 不建议重构
原因：
- 功能内聚性高（统一的动作注册和执行机制）
- 拆分会破坏现有的内聚性
- 成本大于收益

遵循"避免过度拆分"原则
```

## 依赖管理规范

### 1. 导入顺序 📦

**规范：** 每个文件的导入语句必须按照以下顺序组织。

```rust
✅ 正确做法：
// 1. 标准库导入
use std::collections::HashMap;
use std::path::Path;

// 2. 第三方库导入（按字母顺序）
use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use tokio::fs;
use tracing::{debug, error};

// 3. 当前工作空间导入（按模块层级）
use crate::config::AppConfig;
use crate::utils::error::ToTauriResult;

// 4. 父模块导入
use super::TerminalContextState;

❌ 错误做法：
// 导入顺序混乱
use crate::config::AppConfig;
use std::collections::HashMap;
use super::TerminalContextState;
use anyhow::Result;
use crate::utils::error::ToTauriResult;
use tokio::fs;
```

### 2. 模块间依赖规则 🔗

**规范：** 模块间的依赖关系必须保持清晰和单向。

```rust
✅ 正确做法：
// 分层依赖（高层模块依赖低层模块）
commands → service → repository → types
terminal → utils
config → utils

❌ 错误做法：
// 循环依赖
terminal/commands/pane.rs 导入 terminal/commands/context.rs
terminal/commands/context.rs 导入 terminal/commands/pane.rs

// 跨层依赖
commands.rs 直接导入 repository.rs（跳过 service 层）
```

### 3. 重新导出规范 📤

**规范：** 使用重新导出来简化模块使用，但必须有选择性。

```rust
✅ 正确做法：
// src/terminal/commands/mod.rs
// 重新导出所有命令函数，保持向后兼容
pub use pane::{set_active_pane, get_active_pane, clear_active_pane, is_pane_active};
pub use context::{get_terminal_context, get_active_terminal_context};
pub use cache::{invalidate_context_cache, clear_all_context_cache};
pub use stats::{get_context_cache_stats, get_registry_stats};

❌ 错误做法：
// src/terminal/commands/mod.rs
pub use pane::*;     // 导出所有内容，污染命名空间
pub use context::*;  // 可能导致命名冲突
pub use cache::*;    // 缺乏选择性
pub use stats::*;    // 不清楚导出了什么
```

## 代码组织规范

### 1. 功能内聚原则 🧩

**规范：** 相关功能必须组织在同一个模块内，但要避免过度拆分。

```rust
✅ 正确做法：
// src/config/toml/mod.rs - 按管理职责拆分
pub mod manager;     // 主题管理器
pub mod reader;      // 配置读取
pub mod writer;      // 配置写入
pub mod validator;   // 配置验证
pub mod events;      // 事件处理

// 所有TOML配置相关功能都在 toml 模块内

❌ 错误做法：
// 主题相关功能分散在不同位置
src/config/toml_manager.rs      (1190行，职责混杂)
src/validation/toml_validator.rs
src/types/toml_types.rs
src/defaults/toml_defaults.rs
```

### 2. 接口设计规范 🔌

**规范：** 每个模块必须提供清晰、稳定的对外接口。

```rust
✅ 正确做法：
// src/terminal/commands/mod.rs
pub struct TerminalContextState {
    // 私有字段，封装内部状态
    pub registry: Arc<ActiveTerminalContextRegistry>,
    pub context_service: Arc<TerminalContextService>,
}

impl TerminalContextState {
    // 公开的构造函数
    pub fn new(
        registry: Arc<ActiveTerminalContextRegistry>,
        context_service: Arc<TerminalContextService>,
    ) -> Self { ... }

    // 公开的访问方法
    pub fn registry(&self) -> &Arc<ActiveTerminalContextRegistry> { ... }
    pub fn context_service(&self) -> &Arc<TerminalContextService> { ... }
}

// 重新导出核心功能，保持接口稳定
pub use pane::{set_active_pane, get_active_pane};
pub use context::{get_terminal_context, get_active_terminal_context};

❌ 错误做法：
// 暴露过多内部实现
impl TerminalContextState {
    // 不应该公开的内部方法
    pub fn get_internal_state(&self) -> &HashMap<PaneId, InternalState> { ... }
    pub fn raw_registry_access(&self) -> &RwLock<HashMap<...>> { ... }
}
```

## 测试文件组织规范

### 1. 测试文件位置 🧪

**规范：** 测试文件必须与被测试代码保持对应关系。

```text
✅ 正确做法：
src/
├── terminal/
│   ├── commands/
│   │   ├── mod.rs
│   │   ├── pane.rs
│   │   ├── context.rs
│   │   └── cache.rs
│   └── context_service.rs
└── tests/                   # 集成测试目录
    ├── terminal_integration.rs
    └── config_integration.rs

// 单元测试放在各自模块中
#[cfg(test)]
mod tests {
    use super::*;
    // 测试代码
}
```

### 2. 测试模块命名 📝

**规范：** 测试文件和模块必须使用清晰的命名。

```rust
✅ 正确做法：
// src/terminal/commands/pane.rs
#[cfg(test)]
mod tests {
    use super::*;
    use crate::terminal::commands::tests::create_test_state;

    #[tokio::test]
    async fn test_set_and_get_active_pane() { ... }

    #[tokio::test]
    async fn test_invalid_pane_id_validation() { ... }
}
```

## 文档规范

### 1. 模块文档 📚

**规范：** 每个主要模块必须包含完整的文档。

````rust
✅ 正确做法：
/*!
 * 终端上下文管理 Tauri 命令接口
 *
 * 提供前端调用的终端上下文管理命令，包括：
 * - 活跃终端管理
 * - 终端上下文查询
 * - 参数验证和错误处理
 *
 * ## 重构说明
 *
 * 本模块已按功能域重构，原 commands.rs (664行) 拆分为：
 * - pane.rs: 面板管理命令
 * - context.rs: 上下文管理命令
 * - cache.rs: 缓存管理命令
 * - stats.rs: 统计信息命令
 *
 * ## 使用示例
 *
 * ```rust
 * use crate::terminal::commands::{set_active_pane, get_terminal_context};
 *
 * // 使用方式保持不变，向后兼容
 * set_active_pane(pane_id, state).await?;
 * let context = get_terminal_context(None, state).await?;
 * ```
 */
````

## 代码审查清单

在提交代码前，请确认以下事项：

### 基础规范

- [ ] 文件大小符合规范要求（单文件 < 500行）
- [ ] 使用文件夹而非文件名前缀组织代码
- [ ] 模块职责单一，边界清晰
- [ ] 导入语句按规定顺序组织

### 重构规范

- [ ] 遵循统一的重构标准（Commands/Manager/Generator类文件）
- [ ] 避免过度拆分（特别是Types类文件）
- [ ] 评估了重构收益与成本
- [ ] 保持了功能的内聚性

### 接口规范

- [ ] 重新导出有选择性，避免命名冲突
- [ ] 保持对外接口的稳定性和向后兼容
- [ ] 模块间依赖关系清晰，无循环依赖

### 文档规范

- [ ] 添加了必要的模块文档
- [ ] 测试文件组织合理
- [ ] 重构说明文档完整

## 常见反模式

### ❌ 避免这些做法

#### 1. 文件名前缀代替目录结构

```rust
// 不要这样做
pane_commands.rs
context_commands.rs
cache_commands.rs

// 应该这样做
commands/
├── pane.rs
├── context.rs
└── cache.rs
```

#### 2. 过度拆分破坏内聚性

```rust
// 不要过度拆分类型定义文件
types/
├── pane_types.rs      // 类型分散
├── context_types.rs   // 失去关联性
└── cache_types.rs     // 维护困难

// 保持类型定义的内聚性
types.rs               // 相关类型集中管理
```

#### 3. 不遵循统一重构标准

```rust
// 不要不同模块使用不同的拆分方式
module_a/commands/     // 按功能域拆分
├── feature1.rs
└── feature2.rs

module_b/             // 随意拆分
├── cmd_part1.rs
├── cmd_part2.rs      // 命名无意义
└── cmd_part3.rs      // 功能不完整
```

#### 4. 技术分层而非功能分层

```text
// 不要这样组织
src/
├── controllers/
├── services/
├── repositories/
└── models/

// 应该按功能域组织
src/
├── terminal/
├── config/
└── ai/
```

#### 5. 忽略重构收益评估

```rust
// 不要盲目重构大文件
// 先评估：功能域数量、内聚程度、修改频率
// 计算：重构收益 vs 拆分成本

// 高内聚的文件应保持现状
mux/terminal_mux.rs    // 核心系统组件，不建议拆分
config/shortcuts/actions.rs  // 功能内聚，不建议拆分
```

## 重构优先级指南

根据文件特征确定重构优先级：

| 优先级 | 文件特征                            | 行动建议         |
| ------ | ----------------------------------- | ---------------- |
| 🔴 高  | Commands类文件，多功能域，>800行    | 立即按功能域拆分 |
| 🟡 中  | Generator类文件，多技术实现，>700行 | 按技术实现拆分   |
| 🟢 低  | Manager类文件，职责复杂，>600行     | 评估后按职责拆分 |
| ❌ 无  | Types类文件，类型定义，任意行数     | 保持内聚性       |
| ❌ 无  | 核心系统组件，高度集成，任意行数    | 避免拆分风险     |

通过遵循这些升级版规范，我们可以确保 OrbitX 项目的代码结构保持清晰、一致和可维护，同时避免过度拆分带来的负面影响。

---

**版本历史**:

- v1.0 - 初始版本，基础文件结构规范
- v2.0 - 加入重构方法论和统一标准
- v2.1 - 加入避免过度拆分原则和实际重构案例
