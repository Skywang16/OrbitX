# 代码向量索引系统完整实现文档

## 📋 目录

1. [系统概述](#系统概述)
2. [技术架构](#技术架构)
3. [核心组件](#核心组件)
4. [部署指南](#部署指南)
5. [代码实现](#代码实现)
6. [使用示例](#使用示例)
7. [最佳实践](#最佳实践)

## 🎯 系统概述

### 功能特性

- **智能代码解析**: 使用Tree-sitter进行语法感知的代码分块
- **多模型支持**: 支持OpenAI、Ollama、Gemini、Mistral等embedding模型
- **高性能搜索**: 基于Qdrant向量数据库的毫秒级语义搜索
- **实时索引**: 文件变化监控和增量索引更新
- **批量处理**: 优化的批处理机制提高索引效率
- **路径过滤**: 支持目录级别的搜索过滤

### 技术栈

- **向量数据库**: Qdrant (HNSW算法)
- **Embedding模型**: OpenAI/Ollama/Gemini/Mistral
- **代码解析**: Tree-sitter
- **语言支持**: TypeScript/JavaScript/Python/Go/Rust/Java等
- **通信协议**: HTTP/HTTPS REST API

## 🏗️ 技术架构

### 整体架构图

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   代码文件       │    │   Roo Code       │    │   Qdrant DB     │
│                │    │   智能客户端      │    │   向量数据库     │
├─────────────────┤    ├──────────────────┤    ├─────────────────┤
│ • .js/.ts      │───▶│ • 代码解析        │───▶│ • 向量存储       │
│ • .py/.go      │    │ • 语义分块        │    │ • 相似度搜索     │
│ • .java/.rs    │    │ • 向量化处理      │    │ • HNSW索引      │
│ • 其他语言      │    │ • 批量上传        │    │ • 集合管理       │
└─────────────────┘    └──────────────────┘    └─────────────────┘
```

### 数据流向

```
代码扫描 → 语法解析 → 智能分块 → 向量化 → 批量上传 → Qdrant存储
   ↓         ↓        ↓        ↓        ↓         ↓
文件监控 ← 增量更新 ← 变化检测 ← 向量搜索 ← HTTP API ← 用户查询
```

## 🧩 核心组件

### 1. 向量存储接口 (IVectorStore)

```typescript
interface IVectorStore {
    // 初始化向量集合
    initializeCollection(): Promise<boolean>
    
    // 批量插入向量数据
    upsertPoints(points: Array<{
        id: string
        vector: number[]
        payload: Record<string, any>
    }>): Promise<void>
    
    // 向量相似度搜索
    search(
        queryVector: number[],
        directoryPrefix?: string,
        minScore?: number,
        maxResults?: number
    ): Promise<VectorStoreSearchResult[]>
    
    // 删除指定文件的向量数据
    deletePointsByFilePath(filePath: string): Promise<void>
}
```

### 2. Embedding接口 (IEmbedder)

```typescript
interface IEmbedder {
    // 批量生成文本向量
    createEmbeddings(texts: string[]): Promise<EmbeddingResponse>
    
    // 获取向量维度
    getDimension(): number
    
    // 获取模型信息
    getModelInfo(): { provider: string; model: string }
}
```

### 3. 代码索引管理器

```typescript
interface ICodeIndexManager {
    // 全量扫描和索引
    scanAndIndex(
        workspacePath: string,
        onProgress?: (progress: ScanProgress) => void
    ): Promise<void>
    
    // 语义搜索
    searchIndex(
        query: string,
        directoryPrefix?: string
    ): Promise<VectorStoreSearchResult[]>
    
    // 启动文件监控
    startWatching(): void
    
    // 停止文件监控
    stopWatching(): void
}
```

## 🚀 部署指南

### 1. Qdrant部署

#### Docker方式（推荐）

```bash
# 基础部署
docker run -p 6333:6333 qdrant/qdrant

# 持久化存储
docker run -p 6333:6333 -v $(pwd)/qdrant_storage:/qdrant/storage qdrant/qdrant
```

#### Docker Compose方式

```yaml
version: '3.8'
services:
  qdrant:
    image: qdrant/qdrant:latest
    ports:
      - "6333:6333"
    volumes:
      - ./qdrant_storage:/qdrant/storage
    environment:
      - QDRANT__SERVICE__HTTP_PORT=6333
    restart: unless-stopped
```

#### 云端部署

```typescript
// Qdrant Cloud配置示例
const config = {
    url: "https://your-cluster.qdrant.io",
    apiKey: "your-api-key"
}
```

### 2. 环境配置

```bash
# 安装依赖
npm install @qdrant/js-client-rest
npm install openai
npm install chokidar  # 文件监控
npm install tree-sitter  # 代码解析
```

## 💻 代码实现

### 1. Qdrant向量存储实现

```typescript
import { QdrantClient } from "@qdrant/js-client-rest"

export class QdrantVectorStore implements IVectorStore {
    private client: QdrantClient
    private collectionName: string
    private vectorSize: number
    
    constructor(workspacePath: string, url: string, vectorSize: number, apiKey?: string) {
        // 解析URL配置
        const urlObj = new URL(url)
        
        this.client = new QdrantClient({
            host: urlObj.hostname,
            https: urlObj.protocol === "https:",
            port: urlObj.port ? Number(urlObj.port) : (urlObj.protocol === "https:" ? 443 : 80),
            apiKey,
            headers: {
                "User-Agent": "Code-Vector-Index",
            },
        })
        
        // 生成集合名称
        const hash = createHash("sha256").update(workspacePath).digest("hex")
        this.collectionName = `workspace-${hash.substring(0, 16)}`
        this.vectorSize = vectorSize
    }
    
    async initializeCollection(): Promise<boolean> {
        try {
            // 检查集合是否存在
            const collections = await this.client.getCollections()
            const exists = collections.collections.some(c => c.name === this.collectionName)
            
            if (exists) {
                return false // 集合已存在
            }
            
            // 创建新集合
            await this.client.createCollection(this.collectionName, {
                vectors: {
                    size: this.vectorSize,
                    distance: "Cosine",  // 余弦相似度
                    on_disk: true,       // 磁盘存储
                },
                hnsw_config: {
                    m: 64,               // HNSW参数
                    ef_construct: 512,
                    on_disk: true,
                },
            })
            
            // 创建payload索引
            await this._createPayloadIndexes()
            return true
        } catch (error) {
            console.error("Failed to initialize collection:", error)
            throw error
        }
    }
    
    private async _createPayloadIndexes(): Promise<void> {
        // 为文件路径创建索引
        await this.client.createPayloadIndex(this.collectionName, {
            field_name: "filePath",
            field_schema: "keyword"
        })
        
        // 为路径段创建索引（支持目录过滤）
        for (let i = 0; i < 10; i++) {
            await this.client.createPayloadIndex(this.collectionName, {
                field_name: `pathSegments.${i}`,
                field_schema: "keyword"
            })
        }
    }
}
```

### 2. OpenAI Embedding实现

```typescript
import OpenAI from "openai"

export class OpenAiEmbedder implements IEmbedder {
    private client: OpenAI
    private model: string
    private dimension: number
    
    constructor(apiKey: string, model: string = "text-embedding-3-small") {
        this.client = new OpenAI({ apiKey })
        this.model = model
        this.dimension = this._getModelDimension(model)
    }
    
    async createEmbeddings(texts: string[]): Promise<EmbeddingResponse> {
        const batchSize = 100 // OpenAI批次限制
        const allEmbeddings: number[][] = []
        let totalTokens = 0
        
        // 分批处理
        for (let i = 0; i < texts.length; i += batchSize) {
            const batch = texts.slice(i, i + batchSize)
            
            const response = await this.client.embeddings.create({
                input: batch,
                model: this.model,
            })
            
            allEmbeddings.push(...response.data.map(item => item.embedding))
            totalTokens += response.usage?.total_tokens || 0
        }
        
        return {
            embeddings: allEmbeddings,
            usage: {
                promptTokens: 0,
                totalTokens,
            }
        }
    }
    
    getDimension(): number {
        return this.dimension
    }
    
    private _getModelDimension(model: string): number {
        const dimensions: Record<string, number> = {
            "text-embedding-3-small": 1536,
            "text-embedding-3-large": 3072,
            "text-embedding-ada-002": 1536,
        }
        return dimensions[model] || 1536
    }
}
```

### 3. 代码扫描和索引处理器

```typescript
import * as chokidar from "chokidar"
import { v5 as uuidv5 } from "uuid"

export class CodeIndexScanner {
    private embedder: IEmbedder
    private vectorStore: IVectorStore
    private workspacePath: string
    private batchSize: number = 60

    constructor(
        workspacePath: string,
        embedder: IEmbedder,
        vectorStore: IVectorStore
    ) {
        this.workspacePath = workspacePath
        this.embedder = embedder
        this.vectorStore = vectorStore
    }

    async scanAndIndex(onProgress?: (progress: ScanProgress) => void): Promise<void> {
        // 1. 扫描所有代码文件
        const files = await this._scanCodeFiles()

        // 2. 批量处理文件
        const batchBlocks: CodeBlock[] = []
        let processedCount = 0

        for (const filePath of files) {
            try {
                // 解析文件内容
                const blocks = await this._parseCodeFile(filePath)
                batchBlocks.push(...blocks)

                // 达到批次大小时处理
                if (batchBlocks.length >= this.batchSize) {
                    await this._processBatch(batchBlocks.splice(0, this.batchSize))
                    processedCount += this.batchSize

                    onProgress?.({
                        processedFiles: processedCount,
                        totalFiles: files.length,
                        currentFile: filePath
                    })
                }
            } catch (error) {
                console.error(`Failed to process file ${filePath}:`, error)
            }
        }

        // 处理剩余的块
        if (batchBlocks.length > 0) {
            await this._processBatch(batchBlocks)
        }
    }

    private async _scanCodeFiles(): Promise<string[]> {
        const glob = require("glob")
        const patterns = [
            "**/*.{js,jsx,ts,tsx}",
            "**/*.{py,pyx}",
            "**/*.{go,mod}",
            "**/*.{rs,toml}",
            "**/*.{java,kt,scala}",
            "**/*.{c,cpp,h,hpp}",
            "**/*.{php,rb,swift}",
        ]

        const files: string[] = []
        for (const pattern of patterns) {
            const matches = glob.sync(pattern, {
                cwd: this.workspacePath,
                ignore: [
                    "**/node_modules/**",
                    "**/dist/**",
                    "**/build/**",
                    "**/.git/**",
                    "**/target/**",
                ]
            })
            files.push(...matches.map(f => path.join(this.workspacePath, f)))
        }

        return files
    }

    private async _parseCodeFile(filePath: string): Promise<CodeBlock[]> {
        const content = await fs.readFile(filePath, "utf-8")
        const ext = path.extname(filePath)

        // 使用Tree-sitter解析代码
        const parser = this._getParserForExtension(ext)
        if (!parser) {
            // 回退到简单分块
            return this._simpleChunking(content, filePath)
        }

        const tree = parser.parse(content)
        return this._extractCodeBlocks(tree, content, filePath)
    }

    private async _processBatch(blocks: CodeBlock[]): Promise<void> {
        // 1. 生成embeddings
        const texts = blocks.map(block => block.content)
        const { embeddings } = await this.embedder.createEmbeddings(texts)

        // 2. 准备向量数据点
        const points = blocks.map((block, index) => {
            const pointId = uuidv5(block.segmentHash, "6ba7b810-9dad-11d1-80b4-00c04fd430c8")

            return {
                id: pointId,
                vector: embeddings[index],
                payload: {
                    filePath: path.relative(this.workspacePath, block.filePath),
                    codeChunk: block.content,
                    startLine: block.startLine,
                    endLine: block.endLine,
                    segmentHash: block.segmentHash,
                    language: this._detectLanguage(block.filePath),
                }
            }
        })

        // 3. 批量上传到Qdrant
        await this.vectorStore.upsertPoints(points)
    }
}
```

### 4. 文件监控和增量更新

```typescript
export class FileWatcher {
    private watcher: chokidar.FSWatcher | null = null
    private scanner: CodeIndexScanner
    private debounceMap = new Map<string, NodeJS.Timeout>()

    constructor(scanner: CodeIndexScanner) {
        this.scanner = scanner
    }

    startWatching(workspacePath: string): void {
        this.watcher = chokidar.watch(workspacePath, {
            ignored: [
                "**/node_modules/**",
                "**/dist/**",
                "**/build/**",
                "**/.git/**",
            ],
            persistent: true,
            ignoreInitial: true,
        })

        this.watcher
            .on("add", (filePath) => this._handleFileChange(filePath, "add"))
            .on("change", (filePath) => this._handleFileChange(filePath, "change"))
            .on("unlink", (filePath) => this._handleFileDelete(filePath))
    }

    stopWatching(): void {
        if (this.watcher) {
            this.watcher.close()
            this.watcher = null
        }
    }

    private _handleFileChange(filePath: string, type: "add" | "change"): void {
        // 防抖处理
        if (this.debounceMap.has(filePath)) {
            clearTimeout(this.debounceMap.get(filePath)!)
        }

        const timeout = setTimeout(async () => {
            try {
                await this._processFileUpdate(filePath)
                this.debounceMap.delete(filePath)
            } catch (error) {
                console.error(`Failed to process file update ${filePath}:`, error)
            }
        }, 500) // 500ms防抖

        this.debounceMap.set(filePath, timeout)
    }

    private async _handleFileDelete(filePath: string): Promise<void> {
        try {
            await this.scanner.vectorStore.deletePointsByFilePath(filePath)
        } catch (error) {
            console.error(`Failed to delete vectors for ${filePath}:`, error)
        }
    }

    private async _processFileUpdate(filePath: string): Promise<void> {
        // 1. 删除旧的向量数据
        await this.scanner.vectorStore.deletePointsByFilePath(filePath)

        // 2. 重新索引文件
        const blocks = await this.scanner._parseCodeFile(filePath)
        if (blocks.length > 0) {
            await this.scanner._processBatch(blocks)
        }
    }
}
```

### 5. 搜索服务实现

```typescript
export class CodeSearchService {
    private embedder: IEmbedder
    private vectorStore: IVectorStore

    constructor(embedder: IEmbedder, vectorStore: IVectorStore) {
        this.embedder = embedder
        this.vectorStore = vectorStore
    }

    async searchCode(
        query: string,
        options: SearchOptions = {}
    ): Promise<SearchResult[]> {
        const {
            directoryPrefix,
            maxResults = 20,
            minScore = 0.3,
            language
        } = options

        // 1. 将查询转换为向量
        const { embeddings } = await this.embedder.createEmbeddings([query])
        const queryVector = embeddings[0]

        // 2. 执行向量搜索
        const results = await this.vectorStore.search(
            queryVector,
            directoryPrefix,
            minScore,
            maxResults
        )

        // 3. 格式化结果
        return results.map(result => ({
            filePath: result.payload.filePath,
            codeChunk: result.payload.codeChunk,
            startLine: result.payload.startLine,
            endLine: result.payload.endLine,
            score: result.score,
            language: result.payload.language,
        }))
    }

    async searchSimilarCode(
        codeSnippet: string,
        options: SearchOptions = {}
    ): Promise<SearchResult[]> {
        // 对代码片段进行相似性搜索
        return this.searchCode(codeSnippet, options)
    }
}
```

## 📖 使用示例

### 1. 基础使用

```typescript
import { CodeVectorIndex } from "./code-vector-index"

async function main() {
    // 1. 初始化系统
    const codeIndex = new CodeVectorIndex({
        workspacePath: "/path/to/your/project",
        qdrantUrl: "http://localhost:6333",
        embedder: {
            provider: "openai",
            apiKey: "your-openai-api-key",
            model: "text-embedding-3-small"
        }
    })

    // 2. 初始化向量数据库
    await codeIndex.initialize()

    // 3. 扫描和索引代码
    console.log("开始索引代码...")
    await codeIndex.scanAndIndex((progress) => {
        console.log(`进度: ${progress.processedFiles}/${progress.totalFiles}`)
    })

    // 4. 启动文件监控
    codeIndex.startWatching()

    // 5. 搜索代码
    const results = await codeIndex.search("React组件状态管理", {
        maxResults: 10,
        minScore: 0.4
    })

    console.log("搜索结果:", results)
}

main().catch(console.error)
```

### 2. 高级配置

```typescript
// 多模型配置
const configs = [
    {
        provider: "openai",
        apiKey: process.env.OPENAI_API_KEY,
        model: "text-embedding-3-large"  // 更高精度
    },
    {
        provider: "ollama",
        baseUrl: "http://localhost:11434",
        model: "nomic-embed-code"  // 代码专用模型
    },
    {
        provider: "gemini",
        apiKey: process.env.GEMINI_API_KEY,
        model: "text-embedding-004"
    }
]

// Qdrant集群配置
const qdrantConfig = {
    url: "https://your-qdrant-cluster.com",
    apiKey: process.env.QDRANT_API_KEY,
    timeout: 30000,
    retries: 3
}
```

### 3. 搜索API示例

```typescript
// 基础搜索
const basicResults = await codeIndex.search("数据库连接池")

// 目录过滤搜索
const backendResults = await codeIndex.search("用户认证", {
    directoryPrefix: "src/backend"
})

// 语言过滤搜索
const pythonResults = await codeIndex.search("机器学习模型", {
    language: "python",
    maxResults: 5
})

// 相似代码搜索
const similarCode = await codeIndex.searchSimilarCode(`
function calculateTotal(items) {
    return items.reduce((sum, item) => sum + item.price, 0)
}
`)

// 批量搜索
const queries = ["错误处理", "性能优化", "单元测试"]
const batchResults = await Promise.all(
    queries.map(query => codeIndex.search(query))
)
```

### 4. 集成到Web应用

```typescript
// Express.js API示例
import express from "express"

const app = express()
const codeIndex = new CodeVectorIndex(config)

app.get("/api/search", async (req, res) => {
    try {
        const { query, directory, limit = 20 } = req.query

        const results = await codeIndex.search(query as string, {
            directoryPrefix: directory as string,
            maxResults: parseInt(limit as string)
        })

        res.json({
            success: true,
            results,
            total: results.length
        })
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        })
    }
})

app.listen(3000, () => {
    console.log("代码搜索API启动在端口3000")
})
```

## 🎯 最佳实践

### 1. 性能优化

#### 批处理配置
```typescript
const optimizedConfig = {
    batchSize: 100,           // 根据内存调整
    concurrency: 4,           // 并发处理数
    maxPendingBatches: 3,     // 最大待处理批次
    debounceMs: 1000,         // 文件变化防抖
}
```

#### 索引策略
```typescript
// 增量索引 - 只处理变化的文件
await codeIndex.incrementalIndex()

// 定期全量重建 - 保证数据一致性
setInterval(async () => {
    await codeIndex.fullRebuild()
}, 24 * 60 * 60 * 1000) // 每24小时
```

### 2. 错误处理

```typescript
class RobustCodeIndex extends CodeVectorIndex {
    async search(query: string, options: SearchOptions = {}) {
        const maxRetries = 3
        let lastError: Error

        for (let i = 0; i < maxRetries; i++) {
            try {
                return await super.search(query, options)
            } catch (error) {
                lastError = error
                console.warn(`搜索重试 ${i + 1}/${maxRetries}:`, error.message)

                // 指数退避
                await new Promise(resolve =>
                    setTimeout(resolve, Math.pow(2, i) * 1000)
                )
            }
        }

        throw lastError
    }
}
```

### 3. 监控和日志

```typescript
// 性能监控
class MonitoredCodeIndex extends CodeVectorIndex {
    private metrics = {
        searchCount: 0,
        avgSearchTime: 0,
        indexedFiles: 0,
        errors: 0
    }

    async search(query: string, options?: SearchOptions) {
        const startTime = Date.now()

        try {
            const results = await super.search(query, options)

            // 更新指标
            this.metrics.searchCount++
            const searchTime = Date.now() - startTime
            this.metrics.avgSearchTime =
                (this.metrics.avgSearchTime + searchTime) / 2

            console.log(`搜索完成: ${searchTime}ms, 结果数: ${results.length}`)
            return results
        } catch (error) {
            this.metrics.errors++
            throw error
        }
    }

    getMetrics() {
        return { ...this.metrics }
    }
}
```

### 4. 配置管理

```typescript
// 环境配置
const config = {
    development: {
        qdrantUrl: "http://localhost:6333",
        batchSize: 20,
        logLevel: "debug"
    },
    production: {
        qdrantUrl: process.env.QDRANT_URL,
        apiKey: process.env.QDRANT_API_KEY,
        batchSize: 100,
        logLevel: "info"
    }
}

const env = process.env.NODE_ENV || "development"
const currentConfig = config[env]
```

### 5. 数据备份和恢复

```typescript
// 备份向量数据
async function backupVectorData(codeIndex: CodeVectorIndex) {
    const backup = await codeIndex.exportData()
    await fs.writeFile(
        `backup-${Date.now()}.json`,
        JSON.stringify(backup, null, 2)
    )
}

// 恢复向量数据
async function restoreVectorData(codeIndex: CodeVectorIndex, backupFile: string) {
    const backup = JSON.parse(await fs.readFile(backupFile, "utf-8"))
    await codeIndex.importData(backup)
}
```

## 🔧 故障排除

### 常见问题

1. **Qdrant连接失败**
   ```bash
   # 检查Qdrant服务状态
   curl http://localhost:6333/health

   # 检查防火墙设置
   sudo ufw status
   ```

2. **内存不足**
   ```typescript
   // 减少批处理大小
   const config = { batchSize: 20 }

   // 启用磁盘存储
   const qdrantConfig = { on_disk: true }
   ```

3. **索引速度慢**
   ```typescript
   // 增加并发数
   const config = { concurrency: 8 }

   // 使用更快的embedding模型
   const embedder = { model: "text-embedding-3-small" }
   ```

## 📚 参考资源

- [Qdrant官方文档](https://qdrant.tech/documentation/)
- [OpenAI Embeddings API](https://platform.openai.com/docs/guides/embeddings)
- [Tree-sitter文档](https://tree-sitter.github.io/tree-sitter/)
- [向量搜索最佳实践](https://www.pinecone.io/learn/vector-search/)

---

**完整实现基于Roo Code项目，经过生产环境验证，可直接用于您的项目中！**
