# 终端事件系统最优架构设计（提案）

本文档提出 OrbitX 终端事件系统的目标最优架构，旨在在高吞吐、低延迟、强一致、易观测、易测试的前提下，提供对多终端、多事件源的稳定支持。

- 适用范围：`src-tauri/` 后端 + 前端事件订阅与渲染
- 相关现状文件：
  - `/.kiro/specs/terminal-context-refactor/design.md`
  - `/.kiro/specs/terminal-context-refactor/requirements.md`
  - `/.kiro/specs/terminal-context-refactor/tasks.md`
- 现有关键实现参考：
  - 生产端（示例）：`src-tauri/src/mux/io_handler.rs`、`src-tauri/src/mux/batch_processor.rs`
  - 控制层：`src-tauri/src/mux/terminal_mux.rs`
  - 统一事件出站（当前版本）：`src-tauri/src/terminal/event_handler.rs`

---

## 1. 架构目标

- 稳定一致：保证事件顺序与完整性，消除隐式时序与线程生命周期隐患。
- 高吞吐：微批合并 + 有界队列的背压策略，保护内存与前端渲染性能。
- 易观测：关键指标（队列长度、高水位、丢弃计数、最近错误）可查询；日志降噪。
- 易测试：统一的事件总线接口，生产与消费解耦，便于注入 mock 与端到端测试。
- 易扩展：支持多事件源（输出/创建/尺寸/退出/关闭/上下文变更），前端单一订阅入口。

---

## 2. 架构总览

核心理念：以“单消费者异步事件总线（Tokio mpsc）”为中心，将所有终端相关事件统一入队，由一个消费任务统一出站到前端。

事件流路径：

```
PTY 输出 ──> IoHandler/BatchProcessor ──(微批)──>
                                       MuxEventBus (Tokio mpsc, 有界)
                                                │
                                                ▼
                                单消费者异步任务（TerminalEventHandler）
                                   └─> 映射为前端事件名（tauri emit）
                                                │
                                                ▼
                                            前端（单一订阅 + Store 分发）
```

模块角色：

- 生产者（Producers）：
  - `IoHandler` / `BatchProcessor` 负责读取 PTY、做“微批”并产出 `TerminalEvent::Output`。
  - `TerminalMux` 产出控制类事件（`Created/Resized/Closed/Exited`）。
- 事件总线（Event Bus）：
  - `MuxEventBus`（新增 `src-tauri/src/mux/event_bus.rs`）：有界 `tokio::mpsc` 队列；可选 `broadcast`。
- 消费者（Consumer）：
  - `TerminalEventHandler`（重构）：基于 `tauri::async_runtime::spawn` 的单消费者任务，统一出站。
- 前端：
  - 仅注册一次顶层订阅，将事件分发到 Pinia Store；`paneId -> xterm` 的映射在 Store 内维护。

---

## 3. 事件模型与命名

Rust 端统一事件（示例）：

```rust
pub enum TerminalEvent {
    Output { pane_id: u32, data: bytes::Bytes },
    Created { pane_id: u32 },
    Resized { pane_id: u32, cols: u16, rows: u16 },
    Closed  { pane_id: u32 },
    Exited  { pane_id: u32, exit_code: Option<i32> },
    // 语义上下文（可选并行通道或统一总线）
    ActivePaneChanged { old: Option<u32>, new: Option<u32> },
    CwdChanged { pane_id: u32, old: Option<String>, new: Option<String> },
    ShellIntegrationChanged { pane_id: u32, enabled: bool },
}
```

前端事件命名（与现状一致）：

- `terminal_output`
- `terminal_created`
- `terminal_resized`
- `terminal_closed`
- `terminal_exited`
- `active_pane_changed` / `pane_cwd_changed` / `pane_shell_integration_changed`

注意：保证“`terminal_created` 一定先于该 pane 的第一条 `terminal_output` 被前端接收”。单消费者天然保证顺序。

---

## 4. MuxEventBus 设计（新增）

文件：`src-tauri/src/mux/event_bus.rs`

职责：

- 提供统一、可靠的事件入队接口（生产端）。
- 提供单消费者读取端（消费端）。
- 提供（可选）后端广播订阅（`broadcast`），供诊断或其它后端模块使用。

接口草案：

```rust
pub struct MuxEventBus {
    tx: tokio::mpsc::Sender<TerminalEvent>,
    rx: tokio::sync::Mutex<tokio::mpsc::Receiver<TerminalEvent>>, // 单消费者
    btx: tokio::sync::broadcast::Sender<TerminalEvent>,           // 可选
    metrics: Arc<Metrics>,
}

impl MuxEventBus {
    pub fn new(capacity: usize) -> Self { /* ... */ }
    pub fn sender(&self) -> tokio::mpsc::Sender<TerminalEvent> { self.tx.clone() }
    pub async fn recv(&self) -> Option<TerminalEvent> { self.rx.lock().await.recv().await }
    pub fn broadcast(&self, ev: TerminalEvent) -> Result<usize, broadcast::error::SendError<TerminalEvent>> { /* ... */ }
    pub fn shutdown(&self) { /* drop tx，或设置关闭标志 */ }
    pub fn metrics(&self) -> MetricsSnapshot { /* 队列长度、高水位、丢弃字节数、最近错误等 */ }
}
```

背压策略：

- mpsc 使用“有界队列”（建议 4k～16k，可配置）。
- 队列接近满时：
  - 对 `Output` 可进行“合并连续块”或“仅保留最新块并标记截断”。
  - `Created/Resized/Closed/Exited` 等控制事件永不丢弃。

微批策略：

- 保留 `IoHandler/BatchProcessor` 的微批合并，将“块化数据”入队，减少事件风暴。

---

## 5. 单消费者异步任务（TerminalEventHandler 重构）

文件：`src-tauri/src/terminal/event_handler.rs`

启动：在 `src-tauri/src/lib.rs` 应用启动处，使用 `tauri::async_runtime::spawn` 启动消费任务。

消费循环（示意）：

```rust
let bus = get_event_bus(); // 全局/状态注入

tauri::async_runtime::spawn(async move {
    while let Some(ev) = bus.recv().await {
        // 1) 映射为前端事件名 + payload
        let (name, payload) = map_to_frontend(&ev);
        // 2) emit（失败仅记录错误日志，可选重试/降级）
        if let Err(e) = app_handle.emit(name, payload) {
            tracing::error!("emit_failed name={name} err={e}");
        }
        // 3) 可选广播给后端其它订阅者
        let _ = bus.broadcast(ev);
    }
});
```

相较“专用线程 + crossbeam”的优势：

- 与 Tauri 默认 Tokio 运行时一体化；无需手管 JoinHandle/关闭；select/await 自然表达并发。
- 顺序可靠，降低“隐式时序与线程生命周期”风险（避免“线程未启动导致黑屏”的根因）。

---

## 6. 生命周期与关闭

- 启动：在 `tauri::Builder` 初始化期间创建 `MuxEventBus` 单例，随后启动消费任务。
- 关闭：`drop` 所有 mpsc sender，消费任务读完缓冲后自然退出；也可在 `shutdown()` 中显式设置关闭标志。

---

## 7. 日志与指标（可观测性）

- 日志策略：
  - 常态不打印大数据预览（仅错误时截断 50～100B）。
  - 保留 emit 失败、通道断开、状态迁移（创建/关闭/退出）日志。
- 指标接口：
  - `get_mux_metrics`：队列长度、高水位、丢弃字节数/事件数、最近错误时间戳等。
  - 前端提供“开发者面板”读指标以快速诊断。

---

## 8. 与现有规范/任务的对齐

与 `design.md`、`requirements.md`、`tasks.md` 完全对齐并增强：

- 统一事件路径与语义，前端只需单一订阅；
- 活跃上下文（`ActiveTerminalContextRegistry`）保持现有广播语义，可在消费任务中 select 合流；
- 背压/微批保护高吞吐场景，防止通知风暴与 UI 卡顿；
- 生命周期由 runtime 管理，避免“线程未启动/未轮询”的脆弱点；
- 更易测试：可注入 mock sender/receiver，单元/集成/端到端均友好。

---

## 9. 迁移计划（三步）

1. 新增事件总线

- 新建 `src-tauri/src/mux/event_bus.rs`，定义 `TerminalEvent`、`MuxEventBus`、背压/微批策略（生产端仍做微批）。
- 在 `io_handler.rs`、`batch_processor.rs` 中将通知改为 `TerminalEvent::Output` 入队。
- 在 `terminal_mux.rs` 中将创建/尺寸/关闭/退出改为 `TerminalEvent` 入队。

2. 单消费者任务

- 在 `terminal/event_handler.rs` 中改为 `tauri::async_runtime::spawn` 的单消费者任务，统一出站到前端。
- 删除/收敛 `TerminalMux` 内部的订阅/线程路由逻辑，职责回归 Pane 管理。

3. 前端与指标

- 前端只保留一个顶层订阅，分发到 Pinia Store，xterm 写入做 rAF 节流。
- 新增 `get_mux_metrics` 命令与简单调试面板，便于观测。

---

## 10. 风险与回退

- 若某平台对 async 运行时存在兼容问题，可回退为“专用线程 + crossbeam”，但仍坚持：
  - 单消费者；有界队列；统一事件语义；微批与背压策略。
- 因生产端统一入总线，回退只影响消费侧实现，对上层透明，影响面小。

---

## 11. 验收标准（建议）

- 正常场景：
  - 新建/关闭终端、执行命令、调整大小、shell 退出等全链路稳定无丢失。
- 压测场景：
  - 大量输出（如 `yes | head -n 100000`）时前端仍可响应，指标显示有限丢弃且有提示；控制事件（创建/关闭/尺寸）无丢失。
- 观测能力：
  - 能通过 `get_mux_metrics` 查看队列长度、高水位、丢弃数、最近错误时间戳。
- 测试覆盖：
  - 事件总线单元测试；消费任务集成测试；端到端（前端订阅）冒烟测试。

---

## 12. 附录：示例代码片段

事件映射（示例）：

```rust
fn map_to_frontend(ev: &TerminalEvent) -> (&'static str, serde_json::Value) {
    match ev {
        TerminalEvent::Output { pane_id, data } => (
            "terminal_output",
            serde_json::json!({ "pane_id": pane_id, "data": String::from_utf8_lossy(data).to_string() })
        ),
        TerminalEvent::Created { pane_id } => (
            "terminal_created",
            serde_json::json!({ "pane_id": pane_id })
        ),
        TerminalEvent::Resized { pane_id, cols, rows } => (
            "terminal_resized",
            serde_json::json!({ "pane_id": pane_id, "cols": cols, "rows": rows })
        ),
        TerminalEvent::Closed { pane_id } => (
            "terminal_closed",
            serde_json::json!({ "pane_id": pane_id })
        ),
        TerminalEvent::Exited { pane_id, exit_code } => (
            "terminal_exited",
            serde_json::json!({ "pane_id": pane_id, "exit_code": exit_code })
        ),
        TerminalEvent::ActivePaneChanged { old, new } => (
            "active_pane_changed",
            serde_json::json!({ "oldPaneId": old, "newPaneId": new })
        ),
        TerminalEvent::CwdChanged { pane_id, old, new } => (
            "pane_cwd_changed",
            serde_json::json!({ "paneId": pane_id, "oldCwd": old, "newCwd": new })
        ),
        TerminalEvent::ShellIntegrationChanged { pane_id, enabled } => (
            "pane_shell_integration_changed",
            serde_json::json!({ "paneId": pane_id, "enabled": enabled })
        ),
    }
}
```

---

## 结语

该架构与 `design.md / requirements.md / tasks.md` 中的目标完全对齐，并在一致性、背压、观测与测试等方面显著增强。若认可此提案，建议按“新增总线 -> 改造生产端 -> 重构消费端 -> 前端单订阅与指标”三步落地，每步可独立验证与回退。
