# OrbitX 架构分析报告

## 1. 概述

本文档旨在对 OrbitX 项目的现有架构进行深入分析，识别潜在的设计问题、架构坏味道以及改进机会。审查的核心目标是评估系统的模块化、耦合度、职责划分和可维护性，并提出具体的优化建议。

## 2. 核心架构问题分析

在审查过程中，我们发现了几个关键的架构问题，这些问题对系统的可维护性和未来扩展性构成了挑战。

### 2.1. 后端对前端状态的强依赖（高优先级）

**问题描述:**

这是本次审查发现的最核心的问题。AI 模块在构建提示（Prompt）时，需要获取当前活动终端的工作目录 (`currentWorkingDirectory`)。该信息完全由前端的 `useTerminalStore` 维护，并通过 API 接口被动传递给后端。

- **根本原因:** 后端 `TerminalMux` 负责管理所有终端进程，但它本身没有“活动终端”或“用户焦点终端”的概念。这个关键的上下文状态只存在于前端，导致后端核心业务逻辑（AI 上下文构建）依赖于 UI 状态。
- **影响:**
  - **职责不清:** 后端本应能独立获取其管理下的终端信息，现在却需要前端来告知。
  - **高度耦合:** AI 服务与前端视图层（Pinia Store）紧密耦合，违反了分层架构原则。
  - **可测试性差:** 后端服务的单元测试和集成测试变得困难，因为它们需要模拟前端传递的状态。
  - **API 冗余:** 前后端之间的几乎所有与“当前”终端相关的 API 都需要冗余地传递 `paneId` 或 `cwd`，增加了复杂性。

**改进建议:**

将“活动终端”的管理权从前端转移到后端。

1.  **后端增加 `active_pane_id` 状态:** 在 `TerminalMux` 或一个专门的 `SessionManager` 状态管理器中，维护一个全局的 `active_pane_id` 字段。
2.  **创建新的 Tauri 命令:**
    - `set_active_pane(pane_id: u32)`: 当前端用户切换终端标签页时，调用此命令通知后端更新 `active_pane_id`。
    - `get_active_pane()`: 允许后端服务查询当前活动的 Pane ID。
3.  **重构 AI 模块:**
    - 移除 `build_prompt_with_context` 等函数中的 `current_working_directory` 参数。
    - 在函数内部，通过 `get_active_pane()` 获取活动的 `pane_id`，然后调用 `get_pane_cwd(active_pane_id)` 来获取工作目录。
4.  **发送状态变更事件:** 当活动终端变更时，后端可以通过 Tauri 事件系统通知前端，以便 UI 可以做出相应更新（如果需要）。

### 2.2. 重复且混乱的配置管理系统

**问题描述:**

项目后端存在两套独立的配置管理系统，导致职责混乱和潜在的配置冲突。

1.  **主配置系统 (`src-tauri/src/config/`):**
    - 由 `TomlConfigManager` 管理，负责读写 `config.toml`。
    - 结构清晰，通过 Tauri State (`ConfigManagerState`) 安全地暴露给其他模块。
    - 这是系统大部分模块（如 AI、快捷键、主题）使用的配置。
2.  **终端独立配置系统 (`src-tauri/src/mux/config.rs`):**
    - 名为 `TerminalSystemConfig`，从 `terminal-config.toml` 或其他预设路径加载。
    - 使用全局静态变量 `GLOBAL_CONFIG` 进行管理。
    - 这套系统似乎是为终端底层 `mux` 模块专门设计的。

**影响:**

- **违反单一事实来源 (Single Source of Truth):** 两套系统可能包含相同的配置项（如 `shell`、`cwd`），导致不一致。
- **维护困难:** 开发者需要同时理解和维护两套逻辑，增加了心智负担和出错的风险。
- **用户体验差:** 用户需要在不同的地方管理配置，令人困惑。

**改进建议:**

合并两套配置系统，以 `src-tauri/src/config/` 下的主系统为唯一标准。

1.  **迁移配置项:** 将 `TerminalSystemConfig` 中的所有配置项迁移到 `src-tauri/src/config/types.rs` 的 `AppConfig` 结构体中，例如在一个 `[terminal]` 表下。
2.  **移除旧系统:** 废弃并删除 `src-tauri/src/mux/config.rs` 中的整套加载逻辑。
3.  **重构 `mux` 模块:** 修改 `TerminalMux` 模块，使其不再依赖全局静态变量，而是从主配置系统 (`ConfigManagerState`) 中获取所需的终端配置。这可以通过在 `TerminalMux` 初始化时传入配置快照或引用来实现。

## 3. 模块级架构观察与建议

### 3.2. 终端管理模块 (`src-tauri/src/mux/` & `src/stores/Terminal.ts`)

- **优点:**
  - 后端 `TerminalMux` 成功地将底层的 `portable-pty` 抽象出来，提供了清晰的 Pane 管理接口。
  - 前端 `TerminalStore` 提供了良好的终端会话管理和事件监听机制。
- **待改进:**
  - **状态管理问题:** 如 2.1 节所述，缺少后端对“活动终端”的认知。
  - **Shell 集成逻辑分散:** Shell 集成（Shell Integration）的逻辑散布在 `shell/commands.rs` 和 `mux` 模块中，职责不够集中。
  - **建议:** 创建一个专门的 `ShellIntegrationManager` 模块，统一处理所有与 Shell 环境感知（如 `cwd` 获取、命令历史、脚本注入）相关的功能。`TerminalMux` 只负责纯粹的 PTY 管理。

### 3.3. 前后端通信

- **优点:**
  - API 边界清晰，前端通过 `src/api` 中的模块化服务调用 Tauri 命令。
  - 使用 Tauri 事件（如 `terminal_output`, `pane_cwd_changed`）进行后端到前端的通信，是响应式更新的正确方式。
- **待改进:**
  - **过度依赖 `invoke`:** 大量的数据获取型 API 直接暴露为 `invoke` 命令。对于高频或需要持续同步的状态，可以更多地利用事件驱动模型。
  - **建议:** 对于像“所有终端的状态”这样的集合信息，可以考虑建立一个由后端驱动的状态同步机制。后端在终端状态变更时（如创建、关闭、CWD 变更）发出一个包含完整状态快照的事件，前端只需监听此事件即可，无需频繁调用 `list_terminals` 和 `get_pane_shell_state` 等多个命令。

## 4. 总结与后续步骤

OrbitX 项目拥有一个坚实的基础，特别是在 `eko-core` Agent 框架和后端终端管理方面。然而，当前最主要的设计缺陷在于 **后端对前端状态的依赖** 和 **混乱的配置管理**。

解决这两个核心问题将极大地提升系统的内聚性、降低耦合度，并为未来的功能扩展（如多窗口支持、更复杂的 AI Agent）铺平道路。

**建议的行动计划:**

1.  **立即着手解决“活动终端”状态管理问题**，因为它是影响多个模块的核心症结。
2.  **规划配置系统的统一工作**，将其作为下一个重构目标。
3.  **在未来的开发中，严格遵守分层架构原则**，确保后端服务不直接依赖任何前端 UI 状态。所有必要的上下文都应由后端自行管理或通过清晰的 API 参数传递。
